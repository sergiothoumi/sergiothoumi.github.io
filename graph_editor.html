<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph to LaTeX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <style>
        :root {
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-light: #94a3b8;
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --border-color-light: #e2e8f0;
            --border-color-dark: #cbd5e1;
            --background-light: #f8fafc;
            --background-white: #ffffff;
        }

        * { box-sizing: border-box; }

        body {
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: radial-gradient(circle at 10% 20%, rgba(37, 99, 235, 0.08), transparent 25%),
                        radial-gradient(circle at 80% 0%, rgba(16, 185, 129, 0.08), transparent 20%),
                        var(--background-light);
            color: var(--text-primary);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.55rem 0.8rem;
            font-weight: 600;
            font-size: 0.85rem;
            border-radius: 0.65rem;
            transition: all 0.15s ease;
            border: 1px solid transparent;
            cursor: pointer;
            outline: none;
        }

        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--primary-color); color: var(--background-white); box-shadow: 0 10px 30px rgba(37, 99, 235, 0.22); }
        .btn-primary:hover { background-color: var(--primary-hover); }

        .btn-secondary { background-color: var(--background-white); color: var(--text-secondary); border-color: var(--border-color-light); }
        .btn-secondary:hover { background-color: #eef2ff; border-color: #c7d2fe; color: #3730a3; }

        .btn.active { background-color: #1f2937; color: white; border-color: #111827; box-shadow: inset 0 1px 0 rgba(255,255,255,0.1); }

        .form-input, .form-select {
            width: 100%;
            padding: 0.5rem 0.7rem;
            border-radius: 0.6rem;
            border: 1px solid var(--border-color-dark);
            background: var(--background-white);
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }

        .form-input:focus, .form-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.18);
            outline: none;
        }

        .form-checkbox {
            width: 1rem;
            height: 1rem;
            accent-color: var(--primary-color);
        }

        .vertex { cursor: move; }
        .vertex-label { pointer-events: none; user-select: none; font-size: 12px; fill: var(--text-primary); font-family: var(--font-family); }
        .edge, .edge-handle { cursor: pointer; }
        .edge-path {
            fill: none;
            stroke: var(--text-secondary);
            color: var(--text-secondary);
            stroke-width: 1.5px;
        }
        .edge-interaction-area { stroke-width: 12; stroke: transparent; fill: none; }
        .edge-handle { fill: var(--primary-color); opacity: 0.8; transition: transform 0.2s, opacity 0.2s; }
        .edge-handle:hover { opacity: 1; transform: scale(1.05); }
        .vertex.selected .vertex-shape, .edge.selected .edge-path { stroke: var(--warning-color) !important; stroke-width: 3.5px !important; color: var(--warning-color) !important; }
        .vertex.hovered .vertex-shape, .edge.hovered .edge-path { stroke: var(--primary-color) !important; stroke-width: 2.5px !important; color: var(--primary-color) !important; }
        .vertex.edge-start .vertex-shape { animation: pulse 1.5s infinite; }
        .marquee-rect { fill: rgba(37, 99, 235, 0.12); stroke: rgba(37, 99, 235, 0.7); stroke-width: 1px; stroke-dasharray: 3,3; }
        .edge-angle-text { font-family: var(--font-family); font-size: 10px; fill: var(--text-secondary); pointer-events: none; user-select: none; text-anchor: middle; }
        #canvas { cursor: grab; }
        #canvas:active { cursor: grabbing; }
        @keyframes pulse { 0% { stroke-width: 1.5px; } 50% { stroke-width: 4px; stroke: var(--primary-color); } 100% { stroke-width: 1.5px; } }

        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 60;
        }

        .toast {
            background: rgba(15, 23, 42, 0.92);
            color: white;
            padding: 0.65rem 0.9rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.25);
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transform: translateY(-4px);
            animation: toast-in 0.2s forwards ease;
        }

        @keyframes toast-in {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .panel-card {
            background: rgba(255,255,255,0.92);
            border: 1px solid var(--border-color-light);
            border-radius: 1rem;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
            overflow: hidden;
        }

        .toolbar-group { gap: 0.4rem; }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.7rem;
            background: #e0f2fe;
            color: #075985;
            border-radius: 999px;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .status-dot { width: 10px; height: 10px; background: var(--primary-color); border-radius: 999px; box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.2); }
    </style>
</head>
<body class="text-slate-700">

    <div id="toast-container" class="toast-container"></div>

    <!-- Instructions Popup -->
    <div id="instructions-modal" class="hidden fixed bottom-6 left-1/2 -translate-x-1/2 z-20 max-w-xl w-[90%] md:w-[520px] bg-white/95 border border-slate-200 rounded-xl shadow-2xl p-5 space-y-3 pointer-events-auto">
        <div class="flex items-start justify-between gap-2">
            <div>
                <p class="text-xs uppercase tracking-wide text-slate-500 font-semibold mb-1">Quick tips</p>
                <h3 class="text-xl font-semibold leading-tight">How to use the graph editor</h3>
            </div>
            <button id="close-instructions-btn" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="text-sm space-y-2 text-gray-700 leading-relaxed">
            <p><strong>To add a vertex:</strong> Turn on <strong>Add Vertex</strong>, then click anywhere on the canvas.</p>
            <p><strong>To add an edge:</strong> Turn on <strong>Add Edge</strong>, then click the source vertex followed by the target vertex.</p>
            <p><strong>To select items:</strong> Turn on <strong>Select</strong> mode. Click an item. Hold <strong>Shift</strong> while clicking to select multiple items. Click and drag on the background to select items in an area.</p>
            <p><strong>To align vertices:</strong> Select two or more vertices, click the <strong>Align Vertices</strong> dropdown, and choose an alignment.</p>
            <p><strong>To navigate the canvas:</strong> Turn on <strong>Pan</strong> mode. Click and drag the background to pan. Use the mouse wheel to zoom in and out.</p>
            <p><strong>Keyboard Shortcuts:</strong> Use <strong>Ctrl/Cmd + C, X, V</strong> for copy, cut, and paste. Use <strong>Delete/Backspace</strong> to delete selected items.</p>
        </div>
    </div>

    <div class="w-full max-w-full min-h-screen px-4 lg:px-8 py-6 flex flex-col gap-4 flex-1">
        <div class="flex flex-col lg:flex-row gap-4 flex-1 items-stretch">
            <div class="panel-card flex flex-col gap-0 flex-1">
                <div class="bg-white/80 border-b border-slate-200 px-3 py-3 flex flex-wrap items-center gap-2 toolbar-group">
                <div class="flex flex-wrap items-center gap-2">
                    <button id="select-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-fill" viewBox="0 0 16 16"><path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/></svg>Select</button>
                    <button id="pan-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrows-move" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 1 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708l2-2zM7.646 15.854a.5.5 0 0 1 .708 0l2-2a.5.5 0 1 0-.708-.708L8.5 14.293V10.5a.5.5 0 0 0-1 0v3.793l-1.146-1.147a.5.5 0 1 0-.708.708l2 2zM.146 7.646a.5.5 0 0 1 .708 0l2 2a.5.5 0 1 1-.708.708L1.707 8.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 1 1-.708.708l-2-2a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708l-2-2a.5.5 0 0 1 0-.708zM15.854 7.646a.5.5 0 0 0 0 .708l-2 2a.5.5 0 1 0 .708.708l1.147-1.146V8.5H10.5a.5.5 0 0 0 0 1h3.793l-1.147 1.146a.5.5 0 0 0 .708.708l2-2a.5.5 0 0 0 0-.708l-2-2a.5.5 0 0 0-.708.708L14.293 7.5H10.5a.5.5 0 0 0 0 1h3.793l-1.147-1.146a.5.5 0 1 0-.708.708l2 2z"/></svg>Pan</button>
                    <button id="add-vertex-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="6" /></svg>Add Vertex</button>
                    <button id="add-edge-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="12" r="4" /><circle cx="17" cy="12" r="4" /><line x1="11" y1="12" x2="13" y2="12" /></svg>Add Edge</button>
                    <button id="delete-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eraser" viewBox="0 0 16 16"><path d="M8.086 2.207a1.5 1.5 0 0 1 2.121 0l3.586 3.586a1.5 1.5 0 0 1 0 2.121l-5.5 5.5a1.5 1.5 0 0 1-1.06.439H3.914a1.5 1.5 0 0 1-1.06-.439l-1.5-1.5a1.5 1.5 0 0 1 0-2.122l6.732-6.732Zm-5.379 7.44a.5.5 0 0 0-.146.353.5.5 0 0 0 .146.354l1.5 1.5a.5.5 0 0 0 .353.146h3.318a.5.5 0 0 0 .353-.146l3.562-3.562-2.914-2.914-6.172 6.172Z"/></svg>Delete</button>
                    <button id="show-instructions-btn" class="btn btn-secondary">Show Tips</button>
                </div>

                <div class="flex flex-wrap items-center gap-2">
                    <div class="relative">
                        <button id="align-vertices-btn" class="btn btn-secondary">Align Vertices ▾</button>
                        <div id="align-options-dropdown" class="origin-top-left absolute left-0 mt-2 w-56 rounded-lg shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-10" role="menu" aria-orientation="vertical" aria-labelledby="align-vertices-btn">
                            <div class="py-1" role="none"><a href="#" id="align-vertical-btn" class="text-gray-700 block px-4 py-2 text-sm hover:bg-gray-100" role="menuitem">Align Vertically</a><a href="#" id="align-horizontal-btn" class="text-gray-700 block px-4 py-2 text-sm hover:bg-gray-100" role="menuitem">Align Horizontally</a></div>
                        </div>
                    </div>
                    <div class="flex items-center gap-2 bg-white border border-slate-200 px-2 py-1 rounded-lg">
                        <label for="preset-count" class="text-xs font-semibold text-slate-500">Vertices</label>
                        <input type="number" id="preset-count" min="2" value="5" class="form-input text-sm w-20" aria-label="Number of vertices">
                        <select id="preset-shape" class="form-select text-sm w-32">
                            <option value="clique">Clique</option>
                            <option value="cycle">Cycle</option>
                            <option value="path">Path</option>
                            <option value="star">Star</option>
                            <option value="wheel">Wheel</option>
                        </select>
                        <button id="generate-preset-btn" class="btn btn-primary text-xs">Generate</button>
                    </div>
                    <div class="flex items-center gap-2 bg-white border border-slate-200 px-2 py-1 rounded-lg">
                        <label for="auto-label-type" class="text-xs font-semibold text-slate-500">Auto labels</label>
                        <select id="auto-label-type" class="form-select text-sm w-32">
                            <option value="numeric">1, 2, 3…</option><option value="alpha">a, b, c…</option><option value="none">None</option>
                        </select>
                    </div>
                    <button id="undo-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.408a.25.25 0 0 0 0 .384l2.36 2.066A.25.25 0 0 0 8 4.466z"/></svg>Undo</button>
                    <button id="redo-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 2.066a.25.25 0 0 1 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>Redo</button>
                    <button id="copy-btn" class="btn btn-secondary" title="Copy (Ctrl/Cmd + C)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 2a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V6.5L9.5 2z"/><path d="M9.5 2v3a1 1 0 0 0 1 1h3"/></svg>Copy</button>
                    <button id="paste-btn" class="btn btn-secondary" title="Paste (Ctrl/Cmd + V)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10 1.5H6a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1Z"/><path d="M4 3h8v1H4z"/><path d="M6 0a2 2 0 0 0-2 2v1H3a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-1V2a2 2 0 0 0-2-2zm6 4H4V2a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1z"/></svg>Paste</button>
                </div>

                <div class="flex flex-wrap items-center gap-2 ml-auto">
                    <div class="relative">
                        <button id="download-menu-btn" class="btn btn-secondary">Download ▾</button>
                        <div id="download-dropdown" class="hidden absolute right-0 mt-2 w-44 rounded-lg shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none z-10">
                            <div class="py-1">
                                <button id="download-svg-btn" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">SVG</button>
                                <button id="download-png-btn" class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">PNG</button>
                                <button id="download-selected-svg-btn" class="w-full text-left px-4 py-2 text-sm text-gray-400 hover:bg-gray-100 disabled:opacity-50" disabled>Selected as SVG</button>
                                <button id="download-selected-png-btn" class="w-full text-left px-4 py-2 text-sm text-gray-400 hover:bg-gray-100 disabled:opacity-50" disabled>Selected as PNG</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex flex-grow min-h-[65vh]">
                <div class="flex-grow relative bg-white min-h-[65vh]" id="canvas-wrapper">
                    <svg id="canvas" class="w-full h-full min-h-[65vh] rounded-b-xl"></svg>
                    <div class="absolute top-1/2 -translate-y-1/2 right-4 flex flex-col gap-3 bg-white/80 border border-slate-200 rounded-xl shadow p-3">
                        <div class="flex flex-col items-center gap-2 px-1">
                            <span class="text-xs font-semibold text-slate-600">Zoom</span>
                            <input id="zoom-slider" type="range" min="10" max="300" step="5" value="100" class="w-32 accent-blue-600">
                            <span id="zoom-value" class="text-xs font-semibold text-slate-500">100%</span>
                        </div>
                        <div class="flex flex-col gap-2">
                            <button id="zoom-reset-btn" class="btn btn-secondary gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="8"/><polyline points="12 8 8 12 12 16"/><line x1="16" y1="12" x2="8" y2="12"/></svg><span class="text-sm font-semibold">Reset Zoom</span></button>
                        </div>
                    </div>
                </div>
                <aside id="properties-panel" class="w-80 bg-slate-50 border-l border-slate-200 p-4 overflow-y-auto transition-all duration-300 hidden">
                    <div id="vertex-props" class="hidden space-y-4 relative">
                         <button id="close-vertex-props-btn" class="absolute top-0 right-0 text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                        <h3 class="text-lg font-semibold text-gray-800 border-b border-gray-200 pb-2">Vertex Properties</h3>
                        <div class="form-group"><label for="vertex-label">Label</label><input type="text" id="vertex-label" class="form-input"></div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="form-group"><label for="vertex-size">Size</label><select id="vertex-size" class="form-select"><option value="6">Small</option><option value="10" selected>Medium</option><option value="14">Large</option></select></div>
                            <div class="form-group"><label for="vertex-fill-type">Fill</label><select id="vertex-fill-type" class="form-select"><option value="solid">Solid</option><option value="empty">Empty</option></select></div>
                        </div>
                        <div class="form-group" id="vertex-color-group"><label for="vertex-color">Fill Color</label><input type="color" id="vertex-color" value="#628dc6" class="w-full h-10 p-1 border border-gray-300 bg-white rounded-lg"></div>
                        <div class="form-group"><label for="vertex-border">Border</label><select id="vertex-border" class="form-select"><option value="1">Thin</option><option value="1.5" selected>Normal</option><option value="2.5">Thick</option></select></div>
                        <button id="apply-to-all-vertices-btn" class="btn btn-primary w-full justify-center text-center">Apply Styles to All Vertices</button>
                    </div>
                    <div id="edge-props" class="hidden space-y-4 relative">
                        <button id="close-edge-props-btn" class="absolute top-0 right-0 text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                        <h3 class="text-lg font-semibold text-gray-800 border-b border-gray-200 pb-2">Edge Properties</h3>
                        <div class="form-group"><label for="edge-type">Type</label><select id="edge-type" class="form-select"><option value="undirected">Undirected</option><option value="directed">Directed</option></select></div>
                        <div class="form-group"><label for="edge-style">Style</label><select id="edge-style" class="form-select"><option value="solid">Solid</option><option value="dashed">Dashed</option><option value="dotted">Dotted</option></select></div>
                        <div class="form-group"><label for="edge-bend-degree">Bend (degrees)</label><input type="text" id="edge-bend-degree" class="form-input" readonly></div>
                        <div class="form-group flex items-center justify-center"><button id="reset-bend-btn" class="btn btn-secondary">Reset Bend</button></div>
                        <button id="apply-to-all-edges-btn" class="btn btn-primary w-full">Apply Styles to All Edges</button>
                    </div>
                    <div id="no-selection" class="text-center text-gray-500 mt-8"><p>Click an element on the canvas to see its properties.</p><p id="multi-select-info" class="hidden text-sm mt-2">Multiple items selected.</p></div>
                </aside>
            </div>
        </div>

            <div class="panel-card bg-white border border-slate-200 lg:w-[420px]">
                <div class="p-3 flex justify-between items-center border-b border-gray-200 bg-white/60"><h3 class="text-md font-semibold text-gray-800 px-2">Generated TikZ Code</h3><button id="copy-button" class="btn btn-primary">Copy Code</button></div>
                <textarea id="tikz-code" readonly class="flex-grow w-full p-4 box-border border-none font-mono text-sm resize-none bg-white text-gray-800 focus:outline-none" style="min-height: 8rem;"></textarea>
                <div class="bg-white border-t border-gray-200 p-3 flex items-center gap-4 text-sm flex-wrap">
                    <div class="flex items-center gap-2"><input type="checkbox" id="center-drawing-check" class="form-checkbox"><label for="center-drawing-check">Center Drawing</label></div>
                    <div class="flex items-center gap-2"><input type="checkbox" id="add-caption-check" class="form-checkbox"><label for="add-caption-check" id="add-caption-label">Add Caption</label></div>
                    <input type="text" id="caption-input" placeholder="Enter caption text..." class="form-input text-sm py-1 flex-1 min-w-[10rem]" disabled>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const svg = document.getElementById('canvas');
            const propertiesPanel = document.getElementById('properties-panel');
            const noSelectionPanel = document.getElementById('no-selection');
            const multiSelectInfo = document.getElementById('multi-select-info');
            const vertexPropsPanel = document.getElementById('vertex-props');
            const edgePropsPanel = document.getElementById('edge-props');
            const tikzCodeArea = document.getElementById('tikz-code');
            const NS = 'http://www.w3.org/2000/svg';

            let state = { vertices: [], edges: [], nextVertexId: 0, nextEdgeId: 0, selectedElements: [], mode: 'select', edgeStartVertex: null, autoLabelType: 'numeric', draggedElement: null, pan: {x: 0, y: 0}, zoom: 1 };
            let isMarqueeSelecting = false, marqueeRect = null, marqueeStartPoint = { x: 0, y: 0 }, clipboard = { vertices: [], edges: [] }, lastMouseCoords = { x: 0, y: 0 };
            let isPanning = false, panStartPoint = {x: 0, y: 0};
            let history = [], historyPointer = -1;
            const TIKZ_SCALE_FACTOR = 40;

            const selectModeBtn = document.getElementById('select-mode-btn');
            const panModeBtn = document.getElementById('pan-mode-btn');
            const addVertexBtn = document.getElementById('add-vertex-btn');
            const addEdgeBtn = document.getElementById('add-edge-btn');
            const deleteModeBtn = document.getElementById('delete-mode-btn');
            const alignVerticesBtn = document.getElementById('align-vertices-btn');
            const alignOptionsDropdown = document.getElementById('align-options-dropdown');
            const alignVerticalBtn = document.getElementById('align-vertical-btn');
            const alignHorizontalBtn = document.getElementById('align-horizontal-btn');
            const autoLabelTypeSelect = document.getElementById('auto-label-type');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const showInstructionsBtn = document.getElementById('show-instructions-btn');
            const toastContainer = document.getElementById('toast-container');
            const presetCountInput = document.getElementById('preset-count');
            const presetShapeSelect = document.getElementById('preset-shape');
            const generatePresetBtn = document.getElementById('generate-preset-btn');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsBtn = document.getElementById('close-instructions-btn');
            const copyBtn = document.getElementById('copy-button');
            const resetBendBtn = document.getElementById('reset-bend-btn');
            const centerCheck = document.getElementById('center-drawing-check');
            const captionCheck = document.getElementById('add-caption-check');
            const captionInput = document.getElementById('caption-input');
            const applyToAllVerticesBtn = document.getElementById('apply-to-all-vertices-btn');
            const applyToAllEdgesBtn = document.getElementById('apply-to-all-edges-btn');
            const downloadSvgBtn = document.getElementById('download-svg-btn');
            const downloadPngBtn = document.getElementById('download-png-btn');
            const downloadSelectedSvgBtn = document.getElementById('download-selected-svg-btn');
            const downloadSelectedPngBtn = document.getElementById('download-selected-png-btn');
            const downloadMenuBtn = document.getElementById('download-menu-btn');
            const downloadDropdown = document.getElementById('download-dropdown');
            const canvasWrapper = document.getElementById('canvas-wrapper');
            const copyActionBtn = document.getElementById('copy-btn');
            const pasteActionBtn = document.getElementById('paste-btn');
            const zoomResetBtn = document.getElementById('zoom-reset-btn');
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValueLabel = document.getElementById('zoom-value');
            const closeVertexPropsBtn = document.getElementById('close-vertex-props-btn');
            const closeEdgePropsBtn = document.getElementById('close-edge-props-btn');
            const activeModeLabel = document.getElementById('active-mode-label');
            
            const modeButtons = { 'select': selectModeBtn, 'pan': panModeBtn, 'addVertex': addVertexBtn, 'addEdge': addEdgeBtn, 'delete': deleteModeBtn };

            const vertexLabelInput = document.getElementById('vertex-label');
            const vertexSizeSelect = document.getElementById('vertex-size');
            const vertexFillTypeSelect = document.getElementById('vertex-fill-type');
            const vertexColorInput = document.getElementById('vertex-color');
            const vertexColorGroup = document.getElementById('vertex-color-group');
            const vertexBorderSelect = document.getElementById('vertex-border');
            const edgeTypeSelect = document.getElementById('edge-type');
            const edgeStyleSelect = document.getElementById('edge-style');
            const edgeBendDegreeInput = document.getElementById('edge-bend-degree');

            if (canvasWrapper && instructionsModal && instructionsModal.parentElement !== canvasWrapper) {
                canvasWrapper.appendChild(instructionsModal);
            }

            function saveState() { history = history.slice(0, historyPointer + 1); history.push(JSON.parse(JSON.stringify(state))); historyPointer++; updateToolbarButtons(); }
            function undo() { if (historyPointer > 0) { historyPointer--; loadState(history[historyPointer]); } }
            function redo() { if (historyPointer < history.length - 1) { historyPointer++; loadState(history[historyPointer]); } }
            function loadState(newState) { state = JSON.parse(JSON.stringify(newState)); autoLabelTypeSelect.value = state.autoLabelType; setMode(state.mode, true); render(); updateToolbarButtons(); }
            function updateToolbarButtons() {
                undoBtn.disabled = historyPointer <= 0;
                redoBtn.disabled = historyPointer >= history.length - 1;
                const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex');
                alignVerticesBtn.disabled = selectedVertices.length < 2;
                const hasVerticesSelected = selectedVertices.length > 0;
                [downloadSelectedSvgBtn, downloadSelectedPngBtn].forEach(btn => {
                    btn.disabled = !hasVerticesSelected;
                    btn.classList.toggle('text-gray-700', hasVerticesSelected);
                    btn.classList.toggle('text-gray-400', !hasVerticesSelected);
                });
            }
            function getSVGCoords(evt) { const rect = svg.getBoundingClientRect(); const x = (evt.clientX - rect.left) / state.zoom + state.pan.x; const y = (evt.clientY - rect.top) / state.zoom + state.pan.y; return { x, y }; }
            function addVertex(x, y) { const newVertex = { id: state.nextVertexId++, x, y, label: '', radius: 10, fillType: 'solid', fillColor: '#628dc6', borderWidth: 1.5, borderColor: '#6b7280', type: 'vertex' }; const n = state.vertices.length; if (state.autoLabelType === 'numeric') newVertex.label = (n + 1).toString(); else if (state.autoLabelType === 'alpha') newVertex.label = String.fromCharCode(97 + n); state.vertices.push(newVertex); saveState(); selectElement(newVertex); render(); }
            function addEdge(sourceId, targetId) { if (sourceId === targetId || state.edges.some(e => (e.sourceId === sourceId && e.targetId === targetId) || (e.sourceId === targetId && e.targetId === sourceId))) return; const newEdge = { id: state.nextEdgeId++, sourceId, targetId, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } }; state.edges.push(newEdge); saveState(); }
            function deleteSelectedElements() { if (state.selectedElements.length === 0) return; const idsToDelete = new Set(state.selectedElements.map(el => el.id)); const typesToDelete = new Set(state.selectedElements.map(el => el.type)); if (typesToDelete.has('vertex')) { state.vertices = state.vertices.filter(v => !idsToDelete.has(v.id)); state.edges = state.edges.filter(e => !idsToDelete.has(e.sourceId) && !idsToDelete.has(e.targetId)); } if (typesToDelete.has('edge')) { state.edges = state.edges.filter(e => !idsToDelete.has(e.id)); } selectElement(null); saveState(); render(); }
            function alignSelectedVertices(alignmentType) { const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex'); if (selectedVertices.length < 2) return; let avgX = 0, avgY = 0; selectedVertices.forEach(v => { avgX += v.x; avgY += v.y; }); avgX /= selectedVertices.length; avgY /= selectedVertices.length; const selectedIds = new Set(selectedVertices.map(v => v.id)); state.vertices.forEach(v => { if (selectedIds.has(v.id)) { if (alignmentType === 'horizontal') v.y = avgY; if (alignmentType === 'vertical') v.x = avgX; } }); state.edges.forEach(edge => { if (edge.controlPoint.isDefault) { const source = state.vertices.find(v => v.id === edge.sourceId), target = state.vertices.find(v => v.id === edge.targetId); if (source && target) { edge.controlPoint.x = (source.x + target.x) / 2; edge.controlPoint.y = (source.y + target.y) / 2; } } }); saveState(); render(); }
            function copySelection() {
                if (state.selectedElements.length === 0) return;
                const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex');
                const selectedEdges = state.selectedElements.filter(el => el.type === 'edge');
                const selectedVertexIds = new Set(selectedVertices.map(v => v.id));

                const connectedEdges = state.edges.filter(edge =>
                    selectedVertexIds.has(edge.sourceId) && selectedVertexIds.has(edge.targetId)
                );

                const combinedEdges = [...selectedEdges, ...connectedEdges];
                const uniqueEdges = Array.from(new Map(combinedEdges.map(e => [e.id, e])).values());

                clipboard.vertices = JSON.parse(JSON.stringify(selectedVertices));
                clipboard.edges = JSON.parse(JSON.stringify(uniqueEdges));
            }
            function pasteFromClipboard() { if (clipboard.vertices.length === 0 && clipboard.edges.length === 0) return; const oldToNewIdMap = new Map(), newSelection = []; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if (clipboard.vertices.length > 0) { clipboard.vertices.forEach(v => { minX = Math.min(minX, v.x); minY = Math.min(minY, v.y); maxX = Math.max(maxX, v.x); maxY = Math.max(maxY, v.y); }); } else { minX = lastMouseCoords.x; maxX = lastMouseCoords.x; minY = lastMouseCoords.y; maxY = lastMouseCoords.y; } const selectionCenterX = (minX + maxX) / 2, selectionCenterY = (minY + maxY) / 2; const offsetX = lastMouseCoords.x - selectionCenterX, offsetY = lastMouseCoords.y - selectionCenterY; clipboard.vertices.forEach(v => { const oldId = v.id; const newVertex = JSON.parse(JSON.stringify(v)); newVertex.id = state.nextVertexId++; newVertex.x += offsetX; newVertex.y += offsetY; state.vertices.push(newVertex); oldToNewIdMap.set(oldId, newVertex.id); newSelection.push(newVertex); }); clipboard.edges.forEach(e => { const newEdge = JSON.parse(JSON.stringify(e)); newEdge.id = state.nextEdgeId++; newEdge.sourceId = oldToNewIdMap.get(e.sourceId); newEdge.targetId = oldToNewIdMap.get(e.targetId); if (newEdge.sourceId !== undefined && newEdge.targetId !== undefined) { if (!e.controlPoint.isDefault) { newEdge.controlPoint.x += offsetX; newEdge.controlPoint.y += offsetY; } state.edges.push(newEdge); newSelection.push(newEdge); } }); state.selectedElements = newSelection; updatePropertiesPanel(); saveState(); render(); }

            function getLabelForIndex(index) {
                if (state.autoLabelType === 'numeric') return (index + 1).toString();
                if (state.autoLabelType === 'alpha') {
                    const letters = 'abcdefghijklmnopqrstuvwxyz';
                    return letters[index % letters.length] + (index >= letters.length ? Math.floor(index / letters.length) : '');
                }
                return '';
            }

            function generatePresetGraph(shape, count) {
                const parsedCount = parseInt(count, 10);
                if (Number.isNaN(parsedCount) || parsedCount < 2) {
                    showToast('Enter a valid number of vertices (at least 2).');
                    return;
                }

                const minRequired = { clique: 3, cycle: 3, path: 2, star: 3, wheel: 4 }[shape] || 2;
                if (parsedCount < minRequired) {
                    showToast(`A ${shape} needs at least ${minRequired} vertices.`);
                    return;
                }

                const { width, height } = svg.getBoundingClientRect();
                const viewWidth = width / state.zoom;
                const viewHeight = height / state.zoom;
                const defaultCenterX = state.pan.x + viewWidth / 2;
                const defaultCenterY = state.pan.y + viewHeight / 2;
                const radius = Math.min(viewWidth, viewHeight) * 0.32;
                const startIndex = state.vertices.length;
                const newVertices = [];
                const newEdges = [];
                const baseVertexId = state.nextVertexId;

                const addVertex = (x, y, idxOffset = 0) => {
                    const newId = baseVertexId + newVertices.length;
                    newVertices.push({
                        id: newId,
                        x,
                        y,
                        label: getLabelForIndex(startIndex + idxOffset),
                        radius: 10,
                        fillType: 'solid',
                        fillColor: '#628dc6',
                        borderWidth: 1.5,
                        borderColor: '#6b7280',
                        type: 'vertex'
                    });
                    return newId;
                };

                if (shape === 'path') {
                    const spacing = (viewWidth * 0.7) / Math.max(1, parsedCount - 1);
                    for (let i = 0; i < parsedCount; i++) {
                        addVertex(-(viewWidth * 0.35) + i * spacing, 0, i);
                        if (i > 0) {
                            newEdges.push({ id: state.nextEdgeId + newEdges.length, sourceId: baseVertexId + i - 1, targetId: baseVertexId + i, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } });
                        }
                    }
                } else if (shape === 'star') {
                    const hubId = addVertex(0, 0, 0);
                    for (let i = 1; i < parsedCount; i++) {
                        const angle = (2 * Math.PI * (i - 1)) / (parsedCount - 1);
                        const x = radius * 0.5 * Math.cos(angle);
                        const y = radius * 0.5 * Math.sin(angle);
                        const leafId = addVertex(x, y, i);
                        newEdges.push({ id: state.nextEdgeId + newEdges.length, sourceId: hubId, targetId: leafId, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } });
                    }
                } else if (shape === 'wheel') {
                    const hubId = addVertex(0, 0, 0);
                    for (let i = 1; i < parsedCount; i++) {
                        const angle = (2 * Math.PI * (i - 1)) / (parsedCount - 1);
                        const x = radius * 0.6 * Math.cos(angle);
                        const y = radius * 0.6 * Math.sin(angle);
                        const rimId = addVertex(x, y, i);
                        newEdges.push({ id: state.nextEdgeId + newEdges.length, sourceId: hubId, targetId: rimId, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } });
                        const nextIndex = i === parsedCount - 1 ? 1 : i + 1;
                        const nextId = baseVertexId + nextIndex;
                        if (nextId !== rimId) {
                            newEdges.push({ id: state.nextEdgeId + newEdges.length, sourceId: rimId, targetId: nextId, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } });
                        }
                    }
                } else {
                    for (let i = 0; i < parsedCount; i++) {
                        const angle = (2 * Math.PI * i) / parsedCount;
                        const x = radius * Math.cos(angle);
                        const y = radius * Math.sin(angle);
                        addVertex(x, y, i);
                    }

                    if (shape === 'clique') {
                        for (let i = 0; i < parsedCount; i++) {
                            for (let j = i + 1; j < parsedCount; j++) {
                                newEdges.push({ id: state.nextEdgeId + newEdges.length, sourceId: baseVertexId + i, targetId: baseVertexId + j, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } });
                            }
                        }
                    } else if (shape === 'cycle') {
                        for (let i = 0; i < parsedCount; i++) {
                            const target = (i + 1) % parsedCount;
                            newEdges.push({ id: state.nextEdgeId + newEdges.length, sourceId: baseVertexId + i, targetId: baseVertexId + target, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } });
                        }
                    }
                }

                const newBBox = getVerticesBoundingBox(newVertices);
                const existingBBox = getVerticesBoundingBox(state.vertices);
                const targetCenter = existingBBox
                    ? { x: existingBBox.maxX + 80 + (newBBox.maxX - newBBox.minX) / 2, y: (existingBBox.minY + existingBBox.maxY) / 2 }
                    : { x: defaultCenterX, y: defaultCenterY };
                const currentCenter = { x: (newBBox.minX + newBBox.maxX) / 2, y: (newBBox.minY + newBBox.maxY) / 2 };
                const offsetX = targetCenter.x - currentCenter.x;
                const offsetY = targetCenter.y - currentCenter.y;

                newVertices.forEach(v => { v.x += offsetX; v.y += offsetY; });

                state.vertices.push(...newVertices);
                state.edges.push(...newEdges);
                state.nextVertexId += newVertices.length;
                state.nextEdgeId += newEdges.length;
                state.selectedElements = [...newVertices];
                state.edgeStartVertex = null;
                saveState();
                render();
                showToast(`Generated a ${shape} with ${parsedCount} vertices.`);
            }
            function setMode(newMode, fromLoad = false) {
                if (!fromLoad && state.mode === newMode) newMode = 'select';
                state.mode = newMode;
                Object.values(modeButtons).forEach(btn => btn.classList.remove('active'));
                if (modeButtons[state.mode]) modeButtons[state.mode].classList.add('active');
                svg.style.cursor = { 'pan': 'grab', 'addVertex': 'crosshair', 'addEdge': 'pointer', 'delete': 'pointer' }[state.mode] || 'default';
                if (activeModeLabel) activeModeLabel.textContent = state.mode.charAt(0).toUpperCase() + state.mode.slice(1);
                state.edgeStartVertex = null;
                if (!fromLoad) {
                    const hints = {
                        select: 'Select mode: click items or drag to highlight multiple elements.',
                        addVertex: 'Add Vertex mode: click on the canvas to place a vertex.',
                        addEdge: 'Add Edge mode: click a start vertex, then the target vertex.',
                        pan: 'Pan mode: drag the background to move the canvas.',
                        delete: 'Delete mode: click elements to remove them.'
                    };
                    if (hints[state.mode]) showToast(hints[state.mode]);
                }
                render();
            }
            function selectElement(element, isMultiSelect = false) { if (isMultiSelect) { const index = state.selectedElements.findIndex(el => el.id === element.id && el.type === element.type); if (index > -1) state.selectedElements.splice(index, 1); else state.selectedElements.push(element); } else { state.selectedElements = element ? [element] : []; } updatePropertiesPanel(); updateToolbarButtons(); }
            function updatePropertiesPanel() { const selectedCount = state.selectedElements.length; const showSingleSelection = selectedCount === 1; propertiesPanel.classList.toggle('hidden', !showSingleSelection); noSelectionPanel.classList.toggle('hidden', showSingleSelection); multiSelectInfo.classList.add('hidden'); vertexPropsPanel.classList.add('hidden'); edgePropsPanel.classList.add('hidden'); edgeBendDegreeInput.value = ''; if (!showSingleSelection) return; const selected = state.selectedElements[0]; if (selected.type === 'vertex') { vertexPropsPanel.classList.remove('hidden'); const v = selected; vertexLabelInput.value = v.label; vertexSizeSelect.value = v.radius; vertexFillTypeSelect.value = v.fillType; vertexColorInput.value = v.fillColor; vertexBorderSelect.value = v.borderWidth; vertexColorGroup.style.display = v.fillType === 'solid' ? 'block' : 'none'; } else if (selected.type === 'edge') { edgePropsPanel.classList.remove('hidden'); const e = selected; edgeTypeSelect.value = e.edgeType; edgeStyleSelect.value = e.lineStyle; edgeBendDegreeInput.value = `${calculateBendDegree(e).toFixed(1)}°`; } }

            function getEffectiveControlPoint(edge, source, target) {
                return edge.controlPoint.isDefault
                    ? { x: (source.x + target.x) / 2, y: (source.y + target.y) / 2 }
                    : edge.controlPoint;
            }

            function getBorderPoint(from, to, vertex) {
                let dx = to.x - from.x;
                let dy = to.y - from.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) return to;
                const offset = parseFloat(vertex.radius) + (parseFloat(vertex.borderWidth) / 2);
                return {
                    x: to.x - (dx / len) * offset,
                    y: to.y - (dy / len) * offset
                };
            }

            function showToast(message, duration = 2500) {
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                toastContainer.appendChild(toast);
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateY(-4px)';
                    setTimeout(() => toast.remove(), 200);
                }, duration);
            }

            function calculateBendDegree(edge) {
                const source = state.vertices.find(v => v.id === edge.sourceId);
                const target = state.vertices.find(v => v.id === edge.targetId);
                if (!source || !target) return 0;

                const controlPoint = getEffectiveControlPoint(edge, source, target);
                const v1 = { x: source.x - controlPoint.x, y: source.y - controlPoint.y };
                const v2 = { x: target.x - controlPoint.x, y: target.y - controlPoint.y };
                const mag1 = Math.hypot(v1.x, v1.y);
                const mag2 = Math.hypot(v2.x, v2.y);
                if (mag1 === 0 || mag2 === 0) return 0;

                const cosTheta = Math.max(-1, Math.min(1, (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2)));
                const angle = Math.acos(cosTheta) * (180 / Math.PI);
                return Math.max(0, 180 - angle);
            }

            function updateZoomControls() {
                if (zoomSlider) zoomSlider.value = Math.round(state.zoom * 100);
                if (zoomValueLabel) zoomValueLabel.textContent = `${Math.round(state.zoom * 100)}%`;
            }

            function applyZoom(newZoom, anchorX, anchorY) {
                const rect = svg.getBoundingClientRect();
                const clampedZoom = Math.max(0.1, Math.min(10, newZoom));

                const screenX = anchorX - rect.left;
                const screenY = anchorY - rect.top;

                const worldXBefore = (screenX / state.zoom) + state.pan.x;
                const worldYBefore = (screenY / state.zoom) + state.pan.y;

                const worldXAfter = (screenX / clampedZoom) + state.pan.x;
                const worldYAfter = (screenY / clampedZoom) + state.pan.y;

                state.pan.x += worldXBefore - worldXAfter;
                state.pan.y += worldYBefore - worldYAfter;
                state.zoom = clampedZoom;

                updateZoomControls();
                render();
            }

            function render() {
                updateZoomControls();
                const { width, height } = svg.getBoundingClientRect();
                svg.setAttribute('viewBox', `${state.pan.x} ${state.pan.y} ${width / state.zoom} ${height / state.zoom}`);
                svg.innerHTML = ''; // Clear previous render
                const defs = document.createElementNS(NS, 'defs');

                const markerDefault = document.createElementNS(NS, 'marker');
                markerDefault.setAttribute('id', 'arrowhead-default');
                markerDefault.setAttribute('viewBox', '0 -1.5 2.5 3'); 
                markerDefault.setAttribute('refX', '2'); 
                markerDefault.setAttribute('refY', '0');
                markerDefault.setAttribute('markerWidth', '2'); 
                markerDefault.setAttribute('markerHeight', '2');
                markerDefault.setAttribute('orient', 'auto');
                const pathDefault = document.createElementNS(NS, 'path');
                pathDefault.setAttribute('d', 'M0,-1L2,0L0,1');
                pathDefault.setAttribute('fill', 'currentColor');
                markerDefault.appendChild(pathDefault);
                defs.appendChild(markerDefault);

                const markerSelected = document.createElementNS(NS, 'marker');
                markerSelected.setAttribute('id', 'arrowhead-selected');
                markerSelected.setAttribute('viewBox', '-2 -5 10 10');
                markerSelected.setAttribute('refX', '8');
                markerSelected.setAttribute('refY', '0');
                markerSelected.setAttribute('markerWidth', '6');
                markerSelected.setAttribute('markerHeight', '6');
                markerSelected.setAttribute('orient', 'auto');
                const pathSelected = document.createElementNS(NS, 'path');
                pathSelected.setAttribute('d', 'M0,-4L8,0L0,4');
                pathSelected.setAttribute('fill', 'currentColor');
                markerSelected.appendChild(pathSelected);
                defs.appendChild(markerSelected);

                svg.appendChild(defs);

                const isSelected = (el) => state.selectedElements.some(sel => sel.id === el.id && sel.type === el.type);
                
                state.edges.forEach(edge => {
                    const source = state.vertices.find(v => v.id === edge.sourceId);
                    const target = state.vertices.find(v => v.id === edge.targetId);
                    if (!source || !target) return;
                    
                    const g = document.createElementNS(NS, 'g');
                    g.classList.add('edge');
                    if (isSelected(edge)) g.classList.add('selected');
                    
                    if (edge.controlPoint.isDefault) {
                        edge.controlPoint.x = (source.x + target.x) / 2;
                        edge.controlPoint.y = (source.y + target.y) / 2;
                    }
                    
                    const pathEl = document.createElementNS(NS, 'path');
                    pathEl.classList.add('edge-path');

                    const getBorderPoint = (from, to, vertex) => {
                        let dx = to.x - from.x;
                        let dy = to.y - from.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len === 0) return to;
                        const offset = parseFloat(vertex.radius) + (parseFloat(vertex.borderWidth) / 2);
                        return {
                            x: to.x - (dx / len) * offset,
                            y: to.y - (dy / len) * offset
                        };
                    };

                    const controlPoint = getEffectiveControlPoint(edge, source, target);
                    const bendDegree = calculateBendDegree(edge);
                    
                    const finalSource = getBorderPoint(controlPoint, source, source);
                    const finalTarget = getBorderPoint(controlPoint, target, target);

                    pathEl.setAttribute('d', `M ${finalSource.x} ${finalSource.y} Q ${controlPoint.x} ${controlPoint.y} ${finalTarget.x} ${finalTarget.y}`);
                    
                    if (edge.lineStyle === 'dashed') pathEl.style.strokeDasharray = '5,5';
                    if (edge.lineStyle === 'dotted') pathEl.style.strokeDasharray = '1.5,4';
                    
                    if (edge.edgeType === 'directed') {
                        pathEl.setAttribute('marker-end', isSelected(edge) ? 'url(#arrowhead-selected)' : 'url(#arrowhead-default)');
                    }
                    
                    const interactionArea = pathEl.cloneNode();
                    interactionArea.classList.add('edge-interaction-area');
                    g.appendChild(pathEl);
                    g.appendChild(interactionArea);
                    
                    interactionArea.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        if (state.mode === 'delete') {
                            selectElement(edge, false);
                            deleteSelectedElements();
                        } else {
                            selectElement(edge, e.shiftKey);
                            render();
                        }
                    });
                    interactionArea.addEventListener('mouseenter', () => { g.classList.add('hovered'); if (state.mode === 'delete') g.classList.add('delete-mode-hover'); });
                    interactionArea.addEventListener('mouseleave', () => g.classList.remove('hovered', 'delete-mode-hover'));
                    
                    const handle = document.createElementNS(NS, 'circle');
                    handle.classList.add('edge-handle');
                    handle.setAttribute('cx', controlPoint.x);
                    handle.setAttribute('cy', controlPoint.y);
                    handle.setAttribute('r', '6');
                    handle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        const edgeInState = state.edges.find(ed => ed.id === edge.id);
                        if (edgeInState) {
                            const src = state.vertices.find(v => v.id === edgeInState.sourceId);
                            const tgt = state.vertices.find(v => v.id === edgeInState.targetId);
                            if (src && tgt && edgeInState.controlPoint.isDefault) {
                                const cp = getEffectiveControlPoint(edgeInState, src, tgt);
                                edgeInState.controlPoint = { ...cp, isDefault: false };
                            }
                        }
                        state.draggedElement = { type: 'handle', edgeId: edge.id };
                    });

                    g.appendChild(handle);
                    if (isSelected(edge) || (state.draggedElement && state.draggedElement.type === 'handle' && state.draggedElement.edgeId === edge.id)) {
                        const angleLabel = document.createElementNS(NS, 'text');
                        angleLabel.classList.add('edge-angle-text');
                        angleLabel.setAttribute('x', controlPoint.x);
                        angleLabel.setAttribute('y', controlPoint.y - 10);
                        angleLabel.textContent = `${bendDegree.toFixed(1)}°`;
                        g.appendChild(angleLabel);
                    }
                    svg.appendChild(g);
                });

                state.vertices.forEach(vertex => {
                    const g = document.createElementNS(NS, 'g');
                    g.classList.add('vertex');
                    g.setAttribute('transform', `translate(${vertex.x}, ${vertex.y})`);
                    if (isSelected(vertex)) g.classList.add('selected');
                    if (state.edgeStartVertex && state.edgeStartVertex.id === vertex.id) g.classList.add('edge-start');
                    
                    const circle = document.createElementNS(NS, 'circle');
                    circle.classList.add('vertex-shape');
                    circle.setAttribute('r', vertex.radius);
                    circle.style.fill = vertex.fillType === 'solid' ? vertex.fillColor : 'transparent';
                    circle.style.stroke = vertex.borderColor;
                    circle.style.strokeWidth = vertex.borderWidth;
                    
                    const label = document.createElementNS(NS, 'text');
                    label.classList.add('vertex-label');
                    label.textContent = vertex.label;
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('dy', '.3em');
                    
                    g.appendChild(circle);
                    g.appendChild(label);
                    
                    g.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        if (state.mode === 'addEdge') {
                            if (!state.edgeStartVertex) { state.edgeStartVertex = vertex; render(); } 
                            else { addEdge(state.edgeStartVertex.id, vertex.id); state.edgeStartVertex = null; render(); }
                        } else if (state.mode === 'delete') {
                            selectElement(vertex, e.shiftKey);
                            deleteSelectedElements();
                        } else {
                            state.draggedElement = { type: 'vertex', id: vertex.id, startX: e.clientX, startY: e.clientY };
                            if (!isSelected(vertex)) { selectElement(vertex, e.shiftKey); }
                            render();
                        }
                    });
                    g.addEventListener('mouseenter', () => { g.classList.add('hovered'); if (state.mode === 'delete') g.classList.add('delete-mode-hover'); });
                    g.addEventListener('mouseleave', () => g.classList.remove('hovered', 'delete-mode-hover'));
                    svg.appendChild(g);
                });

                if (marqueeRect) { svg.appendChild(marqueeRect); }
                generateTikZ();
            }

            function generateTikZ() { const doCenter = centerCheck.checked, doCaption = captionCheck.checked, captionText = captionInput.value; const hexToName = {}; let colorIndex = 0; state.vertices.forEach(v => { if (!hexToName[v.borderColor]) hexToName[v.borderColor] = `mycolor${colorIndex++}`; if (v.fillType === 'solid' && !hexToName[v.fillColor]) hexToName[v.fillColor] = `mycolor${colorIndex++}`; }); let code = ''; for (const hex in hexToName) code += `\\definecolor{${hexToName[hex]}}{HTML}{${hex.substring(1)}}\n`; if (doCenter || doCaption) code += `\\begin{figure}[h!]\n${doCenter ? '  \\centering\n' : ''}`; code += '  \\begin{tikzpicture}[every node/.style={draw, circle}]\n'; const canvasHeight = svg.getBoundingClientRect().height; const tikzBorder = { 1: 'thin', 1.5: '', 2.5: 'thick' }; const sizeMap = { 6: '0.4cm', 10: '0.6cm', 14: '0.8cm' }; code += '    % Vertices\n'; state.vertices.forEach(v => { const x = (v.x / TIKZ_SCALE_FACTOR).toFixed(2), y = ((canvasHeight - v.y) / TIKZ_SCALE_FACTOR).toFixed(2); let styles = [`draw=${hexToName[v.borderColor]}`]; if (v.fillType === 'solid') styles.push(`fill=${hexToName[v.fillColor]}`); else styles.push('fill=none'); styles.push(`minimum size=${sizeMap[v.radius]}`); if (tikzBorder[v.borderWidth]) styles.push(tikzBorder[v.borderWidth]); code += `    \\node[${styles.join(', ')}] (v${v.id}) at (${x}, ${y}) {${v.label}};\n`; }); code += '\n    % Edges\n'; state.edges.forEach(e => { let styles = []; if (e.edgeType === 'directed') styles.push('-{stealth}'); if (e.lineStyle === 'dashed') styles.push('dashed'); if (e.lineStyle === 'dotted') styles.push('dotted'); const styleString = styles.length > 0 ? `[${styles.join(', ')}]` : ''; const source = state.vertices.find(v => v.id === e.sourceId), target = state.vertices.find(v => v.id === e.targetId); if (!source || !target) return; const isBent = Math.sqrt((e.controlPoint.x - (source.x + target.x)/2)**2 + (e.controlPoint.y - (source.y + target.y)/2)**2) > 2; if (isBent) { const cx = (e.controlPoint.x / TIKZ_SCALE_FACTOR).toFixed(2), cy = ((canvasHeight - e.controlPoint.y) / TIKZ_SCALE_FACTOR).toFixed(2); code += `    \\draw${styleString} (v${e.sourceId}) .. controls (${cx},${cy}) .. (v${e.targetId});\n`; } else code += `    \\draw${styleString} (v${e.sourceId}) -- (v${e.targetId});\n`; }); code += '  \\end{tikzpicture}'; if (doCenter || doCaption) { if (doCaption && captionText) code += `\n  \\caption{${captionText}}\n`; code += '\\end{figure}'; } tikzCodeArea.value = code; }

            function getVerticesBoundingBox(vertices) {
                if (!vertices || vertices.length === 0) return null;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                vertices.forEach(v => {
                    const radius = parseFloat(v.radius) + (parseFloat(v.borderWidth || 0) / 2);
                    minX = Math.min(minX, v.x - radius);
                    minY = Math.min(minY, v.y - radius);
                    maxX = Math.max(maxX, v.x + radius);
                    maxY = Math.max(maxY, v.y + radius);
                });
                return { minX, minY, maxX, maxY };
            }

            function getBoundingBox(elements) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let hasElement = false;

                const vertices = elements.filter(el => el.type === 'vertex');
                vertices.forEach(v => {
                    const radius = parseFloat(v.radius) + (parseFloat(v.borderWidth || 0) / 2);
                    minX = Math.min(minX, v.x - radius);
                    minY = Math.min(minY, v.y - radius);
                    maxX = Math.max(maxX, v.x + radius);
                    maxY = Math.max(maxY, v.y + radius);
                    hasElement = true;
                });

                const edges = elements.filter(el => el.type === 'edge');
                edges.forEach(edge => {
                    const source = state.vertices.find(v => v.id === edge.sourceId);
                    const target = state.vertices.find(v => v.id === edge.targetId);
                    if (!source || !target) return;

                    const controlPoint = getEffectiveControlPoint(edge, source, target);
                    const padding = Math.max(
                        parseFloat(source.radius) + parseFloat(source.borderWidth || 0),
                        parseFloat(target.radius) + parseFloat(target.borderWidth || 0),
                        6
                    );

                    [source, target, controlPoint].forEach(pt => {
                        minX = Math.min(minX, pt.x - padding);
                        minY = Math.min(minY, pt.y - padding);
                        maxX = Math.max(maxX, pt.x + padding);
                        maxY = Math.max(maxY, pt.y + padding);
                    });
                    hasElement = true;
                });

                return hasElement ? { minX, minY, maxX, maxY } : null;
            }

            // --- START: FIXED DOWNLOAD FUNCTIONS ---

            function getSVGForExport(elements) {
                const verticesToExport = elements.filter(el => el.type === 'vertex');
                const edgesToExport = elements.filter(el => el.type === 'edge');
                const vertexIdsToExport = new Set(verticesToExport.map(v => v.id));

                // This filter is now redundant if the calling function pre-filters, but it's safe to keep.
                const validEdges = edgesToExport.filter(edge =>
                    vertexIdsToExport.has(edge.sourceId) && vertexIdsToExport.has(edge.targetId)
                );

                let svgString = `<svg xmlns="${NS}">`;

                // 1. Add Defs (arrowheads)
                if (svg.querySelector('defs')) {
                    svgString += svg.querySelector('defs').outerHTML;
                }

                // 2. Add Styles (for vertices)
                const cssStyles = `
                    .vertex-label { font-family: 'Inter', sans-serif; font-size: 12px; fill: #1d2129; user-select: none; }
                `;
                svgString += `<style>${cssStyles}</style>`;

                // 3. Add Edges with inline styles
                validEdges.forEach(edge => {
                    const source = state.vertices.find(v => v.id === edge.sourceId);
                    const target = state.vertices.find(v => v.id === edge.targetId);
                    if (!source || !target) return;

                    const controlPoint = edge.controlPoint.isDefault ? { x: (source.x + target.x) / 2, y: (source.y + target.y) / 2 } : edge.controlPoint;
                    
                    const finalSource = getBorderPoint(controlPoint, source, source);
                    const finalTarget = getBorderPoint(controlPoint, target, target);
                    const pathD = `M ${finalSource.x} ${finalSource.y} Q ${controlPoint.x} ${controlPoint.y} ${finalTarget.x} ${finalTarget.y}`;
                    
                    let styles = [
                        'fill: none',
                        'stroke: #6b7280', // Default color
                        'stroke-width: 1.5px' // Default width
                    ];

                    if (edge.lineStyle === 'dashed') styles.push('stroke-dasharray: 5,5');
                    if (edge.lineStyle === 'dotted') styles.push('stroke-dasharray: 1.5,4');
                    
                    const styleString = `style="${styles.join(';')}"`;

                    let marker = '';
                    if (edge.edgeType === 'directed') marker = `marker-end="url(#arrowhead-default)" color="#6b7280"`;

                    svgString += `<path d="${pathD}" ${styleString} ${marker} />`;
                });

                // 4. Add Vertices
                verticesToExport.forEach(vertex => {
                    svgString += `<g class="vertex" transform="translate(${vertex.x}, ${vertex.y})">`;
                    const fill = vertex.fillType === 'solid' ? vertex.fillColor : 'transparent';
                    svgString += `<circle class="vertex-shape" r="${vertex.radius}" style="fill: ${fill}; stroke: ${vertex.borderColor}; stroke-width: ${vertex.borderWidth};" />`;
                    svgString += `<text class="vertex-label" text-anchor="middle" dy=".3em">${vertex.label}</text>`;
                    svgString += `</g>`;
                });

                svgString += `</svg>`;
                return svgString;
            }

            function downloadImage(isPng, selectedOnly) {
                let elementsToExport;

                if (selectedOnly) {
                    const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex');
                    const selectedVertexIds = new Set(selectedVertices.map(v => v.id));

                    const connectingEdges = state.edges.filter(edge =>
                        selectedVertexIds.has(edge.sourceId) && selectedVertexIds.has(edge.targetId)
                    );

                    elementsToExport = [...selectedVertices, ...connectingEdges];
                    if (elementsToExport.length === 0) {
                        showToast('Select at least one vertex to export the selection.');
                        return;
                    }
                } else {
                    elementsToExport = [...state.vertices, ...state.edges];
                }

                const bbox = getBoundingBox(elementsToExport) || { minX: 0, minY: 0, maxX: 100, maxY: 100 };
                const padding = 20;
                const contentWidth = (bbox.maxX - bbox.minX) + padding * 2;
                const contentHeight = (bbox.maxY - bbox.minY) + padding * 2;
                
                const rawSvgData = getSVGForExport(elementsToExport);
                const finalSVGData = rawSvgData.replace(
                    /<svg[^>]+>/, 
                    `<svg width="${contentWidth}" height="${contentHeight}" viewBox="${bbox.minX - padding} ${bbox.minY - padding} ${contentWidth} ${contentHeight}" xmlns="http://www.w3.org/2000/svg">`
                );
                
                const blob = new Blob([finalSVGData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                if (isPng) {
                    const canvasEl = document.createElement('canvas');
                    const scale = 2; // For higher resolution PNG
                    canvasEl.width = contentWidth * scale;
                    canvasEl.height = contentHeight * scale;
                    const ctx = canvasEl.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

                    const img = new Image();
                    img.onload = function () {
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(url);
                        const a = document.createElement('a');
                        a.href = canvasEl.toDataURL('image/png');
                        a.download = selectedOnly ? 'graph-selection.png' : 'graph.png';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    };
                    img.onerror = function() {
                        console.error("Error loading SVG image for PNG conversion.");
                        URL.revokeObjectURL(url);
                    }
                    img.src = url;
                } else {
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = selectedOnly ? 'graph-selection.svg' : 'graph.svg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            // --- END: FIXED DOWNLOAD FUNCTIONS ---

            function zoomCanvas(direction, mouseX, mouseY) {
                const zoomFactor = direction === 'in' ? 1.2 : 1 / 1.2;
                applyZoom(state.zoom * zoomFactor, mouseX, mouseY);
            }

            // Event Listeners
            selectModeBtn.addEventListener('click', () => setMode('select'));
            panModeBtn.addEventListener('click', () => setMode('pan'));
            addVertexBtn.addEventListener('click', () => setMode('addVertex'));
            addEdgeBtn.addEventListener('click', () => setMode('addEdge'));
            deleteModeBtn.addEventListener('click', () => setMode('delete'));
            alignVerticesBtn.addEventListener('click', (e) => {
                if (alignVerticesBtn.disabled) return;
                e.stopPropagation();
                alignOptionsDropdown.classList.toggle('hidden');
            });
            alignVerticalBtn.addEventListener('click', (e) => { e.preventDefault(); alignSelectedVertices('vertical'); alignOptionsDropdown.classList.add('hidden'); });
            alignHorizontalBtn.addEventListener('click', (e) => { e.preventDefault(); alignSelectedVertices('horizontal'); alignOptionsDropdown.classList.add('hidden'); });
            window.addEventListener('click', () => { if (!alignOptionsDropdown.classList.contains('hidden')) { alignOptionsDropdown.classList.add('hidden'); } });
            autoLabelTypeSelect.addEventListener('change', (e) => {
                state.autoLabelType = e.target.value;
                state.vertices.forEach((vertex, i) => {
                    if (state.autoLabelType === 'numeric') {
                        vertex.label = (i + 1).toString();
                    } else if (state.autoLabelType === 'alpha') {
                        vertex.label = String.fromCharCode(97 + i);
                    } else {
                        vertex.label = '';
                    }
                });
                saveState();
                render();
            });
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            const showInstructions = () => instructionsModal.classList.remove('hidden');
            const hideInstructions = () => instructionsModal.classList.add('hidden');

            showInstructionsBtn.addEventListener('click', (e) => { e.stopPropagation(); showInstructions(); });
            closeInstructionsBtn.addEventListener('click', hideInstructions);
            canvasWrapper.addEventListener('click', (e) => {
                if (!instructionsModal.classList.contains('hidden') && !instructionsModal.contains(e.target) && e.target !== showInstructionsBtn) {
                    hideInstructions();
                }
            });
            copyBtn.addEventListener('click', () => { tikzCodeArea.select(); document.execCommand('copy'); copyBtn.textContent = 'Copied!'; setTimeout(() => { copyBtn.textContent = 'Copy Code'; }, 2000); });
            resetBendBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'edge') { state.selectedElements[0].controlPoint.isDefault = true; updatePropertiesPanel(); saveState(); render(); } });
            applyToAllVerticesBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'vertex') { const style = state.selectedElements[0]; state.vertices.forEach(v => { v.radius = style.radius; v.fillType = style.fillType; v.fillColor = style.fillColor; v.borderWidth = style.borderWidth; v.borderColor = style.borderColor; }); saveState(); render(); } });
            applyToAllEdgesBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'edge') { const style = state.selectedElements[0]; state.edges.forEach(e => { e.edgeType = style.edgeType; e.lineStyle = style.lineStyle; }); saveState(); render(); } });
            centerCheck.addEventListener('change', generateTikZ);
            captionCheck.addEventListener('change', () => { captionInput.disabled = !captionCheck.checked; generateTikZ(); });
            captionInput.addEventListener('input', generateTikZ);
            generatePresetBtn.addEventListener('click', () => generatePresetGraph(presetShapeSelect.value, presetCountInput.value));

            downloadMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                downloadDropdown.classList.toggle('hidden');
            });
            downloadSvgBtn.addEventListener('click', () => { downloadDropdown.classList.add('hidden'); downloadImage(false, false); });
            downloadPngBtn.addEventListener('click', () => { downloadDropdown.classList.add('hidden'); downloadImage(true, false); });
            downloadSelectedSvgBtn.addEventListener('click', () => { downloadDropdown.classList.add('hidden'); downloadImage(false, true); });
            downloadSelectedPngBtn.addEventListener('click', () => { downloadDropdown.classList.add('hidden'); downloadImage(true, true); });
            document.addEventListener('click', (e) => {
                if (!downloadDropdown.contains(e.target) && e.target !== downloadMenuBtn) {
                    downloadDropdown.classList.add('hidden');
                }
                if (!alignOptionsDropdown.contains(e.target) && e.target !== alignVerticesBtn) {
                    alignOptionsDropdown.classList.add('hidden');
                }
            });

            if (zoomSlider) {
                zoomSlider.addEventListener('input', () => {
                    const { width, height } = svg.getBoundingClientRect();
                    const targetZoom = parseInt(zoomSlider.value, 10) / 100;
                    applyZoom(targetZoom, width / 2, height / 2);
                });
            }
            zoomResetBtn.addEventListener('click', () => { state.zoom = 1; state.pan = { x: 0, y: 0 }; updateZoomControls(); render(); });
            closeVertexPropsBtn.addEventListener('click', () => { selectElement(null); propertiesPanel.classList.add('hidden'); });
            closeEdgePropsBtn.addEventListener('click', () => { selectElement(null); propertiesPanel.classList.add('hidden'); });

            svg.addEventListener('wheel', (e) => { e.preventDefault(); zoomCanvas(e.deltaY < 0 ? 'in' : 'out', e.clientX, e.clientY); });

            svg.addEventListener('mousedown', (e) => {
                if (e.target !== svg) return;
                if (state.mode === 'pan') {
                    isPanning = true;
                    panStartPoint = { x: e.clientX, y: e.clientY };
                } else if (state.mode === 'addVertex') {
                    const coords = getSVGCoords(e);
                    addVertex(coords.x, coords.y);
                } else if (state.mode === 'select') {
                    isMarqueeSelecting = true;
                    marqueeStartPoint = getSVGCoords(e);
                    marqueeRect = document.createElementNS(NS, 'rect');
                    marqueeRect.classList.add('marquee-rect');
                    marqueeRect.setAttribute('x', marqueeStartPoint.x);
                    marqueeRect.setAttribute('y', marqueeStartPoint.y);
                    marqueeRect.setAttribute('width', 0);
                    marqueeRect.setAttribute('height', 0);
                    svg.appendChild(marqueeRect);
                }
            });

            window.addEventListener('mousemove', (e) => {
                const coords = getSVGCoords(e);
                lastMouseCoords = coords;
                if (isPanning) {
                    const dx = (e.clientX - panStartPoint.x) / state.zoom;
                    const dy = (e.clientY - panStartPoint.y) / state.zoom;
                    state.pan.x -= dx;
                    state.pan.y -= dy;
                    panStartPoint = { x: e.clientX, y: e.clientY };
                    render();
                    return;
                }
                if (isMarqueeSelecting && marqueeRect) { const x = Math.min(coords.x, marqueeStartPoint.x), y = Math.min(coords.y, marqueeStartPoint.y), width = Math.abs(coords.x - marqueeStartPoint.x), height = Math.abs(coords.y - marqueeStartPoint.y); marqueeRect.setAttribute('x', x); marqueeRect.setAttribute('y', y); marqueeRect.setAttribute('width', width); marqueeRect.setAttribute('height', height); return; }
                if (!state.draggedElement) return;
                
                if (state.draggedElement.type === 'vertex') {
                    const dx = (e.clientX - state.draggedElement.startX) / state.zoom;
                    const dy = (e.clientY - state.draggedElement.startY) / state.zoom;
                    
                    const selectedVertexIds = new Set(state.selectedElements.filter(el => el.type === 'vertex').map(v => v.id));
                    if (!selectedVertexIds.has(state.draggedElement.id)) {
                        const draggedVertex = state.vertices.find(v => v.id === state.draggedElement.id);
                        draggedVertex.x += dx;
                        draggedVertex.y += dy;
                    } else {
                        state.vertices.forEach(v => { if (selectedVertexIds.has(v.id)) { v.x += dx; v.y += dy; } });
                    }
                    state.draggedElement.startX = e.clientX;
                    state.draggedElement.startY = e.clientY;
                } else if (state.draggedElement.type === 'handle') {
                    const edge = state.edges.find(e => e.id === state.draggedElement.edgeId);
                    if (edge) { edge.controlPoint.x = coords.x; edge.controlPoint.y = coords.y; edge.controlPoint.isDefault = false; updatePropertiesPanel(); }
                }
                render();
            });

            window.addEventListener('mouseup', (e) => {
                isPanning = false;
                if (isMarqueeSelecting && marqueeRect) {
                    const x = parseFloat(marqueeRect.getAttribute('x')), y = parseFloat(marqueeRect.getAttribute('y')), width = parseFloat(marqueeRect.getAttribute('width')), height = parseFloat(marqueeRect.getAttribute('height'));
                    const selectedInBox = state.vertices.filter(v => v.x >= x && v.x <= x + width && v.y >= y && v.y <= y + height);
                    
                    if (e.shiftKey) {
                        selectedInBox.forEach(item => { if (!state.selectedElements.some(sel => sel.type === item.type && sel.id === item.id)) { state.selectedElements.push(item); } });
                    } else {
                        state.selectedElements = selectedInBox;
                    }
                    marqueeRect.remove();
                    marqueeRect = null;
                    isMarqueeSelecting = false;
                    updatePropertiesPanel();
                    updateToolbarButtons();
                    render();
                }
                if (state.draggedElement) {
                    if (state.draggedElement.type === 'vertex') {
                        saveState();
                    } else if (state.draggedElement.type === 'handle') {
                        saveState();
                    }
                    state.draggedElement = null;
                    render();
                }
            });

            window.addEventListener('keydown', (e) => { if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; const isCtrlOrMeta = e.ctrlKey || e.metaKey; if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedElements(); else if (e.key === 'Escape') { setMode('select'); selectElement(null); render(); } else if (e.key === 'e' && !isCtrlOrMeta) { e.preventDefault(); addEdgeBtn.click(); } else if (e.key === 'l' && !isCtrlOrMeta) { e.preventDefault(); const opts = Array.from(autoLabelTypeSelect.options); const curIdx = opts.findIndex(opt => opt.value === state.autoLabelType); autoLabelTypeSelect.value = opts[(curIdx + 1) % opts.length].value; autoLabelTypeSelect.dispatchEvent(new Event('change')); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'c') { e.preventDefault(); copySelection(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'x') { e.preventDefault(); copySelection(); deleteSelectedElements(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'v') { e.preventDefault(); pasteFromClipboard(); } });
            
            const inputs = [vertexLabelInput, vertexSizeSelect, vertexFillTypeSelect, vertexColorInput, vertexBorderSelect, edgeTypeSelect, edgeStyleSelect];
            inputs.forEach(input => { input.addEventListener('change', (e) => { if (state.selectedElements.length !== 1) return; const el = state.selectedElements[0]; switch (e.target.id) { case 'vertex-label': el.label = e.target.value; break; case 'vertex-size': el.radius = parseInt(e.target.value); break; case 'vertex-fill-type': el.fillType = e.target.value; vertexColorGroup.style.display = el.fillType === 'solid' ? 'block' : 'none'; break; case 'vertex-color': el.fillColor = e.target.value; break; case 'vertex-border': el.borderWidth = parseFloat(e.target.value); break; case 'edge-type': el.edgeType = e.target.value; break; case 'edge-style': el.lineStyle = e.target.value; break; } saveState(); render(); }); });

            copyActionBtn.addEventListener('click', () => copySelection());
            pasteActionBtn.addEventListener('click', () => pasteFromClipboard());

            saveState();
            setMode('select');
        });
    </script>

</body>
</html>
