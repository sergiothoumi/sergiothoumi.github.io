<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph to LaTeX Exporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --text-primary: #1d2129;
            --text-secondary: #6b7280;
            --text-light: #94a3b8;
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --danger-color: #ef4444;
            --danger-hover: #dc2626;
            --warning-color: #f59e0b;
            --border-color-light: #cbd5e1;
            --border-color-dark: #6b7280;
            --background-light: #f3f4f6;
            --background-white: #ffffff;
        }
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .btn {
            @apply px-3 py-1.5 rounded-lg font-medium text-xs transition-all duration-150 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2;
            border-radius: 0.5rem;
        }
        .btn-primary { background-color: var(--primary-color); color: var(--background-white); }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-secondary { background-color: var(--background-white); color: var(--text-secondary); border: 1px solid var(--border-color-light); }
        .btn-secondary:hover { background-color: var(--background-light); }
        .btn.active { background-color: var(--primary-color); color: var(--background-white); border-color: var(--primary-color); }
        .form-input, .form-select { @apply block w-full px-3 py-2 bg-white border border-gray-300 rounded-lg shadow-sm placeholder-gray-400 text-gray-900 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm; }
        .form-checkbox { @apply w-4 h-4 bg-gray-100 border-gray-300 rounded text-blue-600 focus:ring-blue-500 disabled:opacity-50; }
        .vertex { cursor: move; }
        .vertex-label { pointer-events: none; user-select: none; font-size: 12px; fill: var(--text-primary); font-family: var(--font-family); }
        .edge, .edge-handle { cursor: pointer; }
        .edge-path {
            fill: none;
            stroke: var(--text-secondary);
            color: var(--text-secondary); /* Sets color for marker */
            stroke-width: 1.5px;
        }
        .edge-interaction-area { stroke-width: 12; stroke: transparent; fill: none; }
        .edge-handle { fill: var(--primary-color); opacity: 0.7; transition: opacity 0.2s; }
        .edge-handle:hover { opacity: 1; }
        .vertex.selected .vertex-shape, .edge.selected .edge-path { stroke: var(--warning-color) !important; stroke-width: 3.5px !important; color: var(--warning-color) !important; }
        .vertex.hovered .vertex-shape, .edge.hovered .edge-path { stroke: var(--primary-color) !important; stroke-width: 2.5px !important; color: var(--primary-color) !important; }
        .vertex.edge-start .vertex-shape { animation: pulse 1.5s infinite; }
        .marquee-rect { fill: rgba(59, 130, 246, 0.2); stroke: rgba(59, 130, 246, 0.7); stroke-width: 1px; stroke-dasharray: 3, 3; }
        .edge-angle-text {
            font-family: var(--font-family);
            font-size: 10px;
            fill: var(--text-secondary);
            pointer-events: none;
            user-select: none;
            text-anchor: middle;
        }
        #canvas {
            cursor: grab;
        }
        #canvas:active {
            cursor: grabbing;
        }
        @keyframes pulse {
            0% { stroke-width: 1.5px; }
            50% { stroke-width: 4px; stroke: var(--primary-color); }
            100% { stroke-width: 1.5px; }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-700">

    <!-- Instructions Popup -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg relative">
            <button id="close-instructions-btn" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
            <h3 class="text-lg font-bold mb-4">Instructions</h3>
            <div class="text-sm space-y-2 text-gray-700">
                <p><strong>To add a vertex:</strong> Turn on <strong>Add Vertex</strong>, then click anywhere on the canvas.</p>
                <p><strong>To add an edge:</strong> Turn on <strong>Add Edge</strong>, then click the source vertex followed by the target vertex.</p>
                <p><strong>To select items:</strong> Turn on <strong>Select</strong> mode. Click an item. Hold <strong>Shift</strong> while clicking to select multiple items. Click and drag on the background to select items in an area.</p>
                <p><strong>To align vertices:</strong> Select two or more vertices, click the <strong>Align Vertices</strong> dropdown, and choose an alignment.</p>
                <p><strong>To navigate the canvas:</strong> Turn on <strong>Pan</strong> mode. Click and drag the background to pan. Use the mouse wheel to zoom in and out.</p>
                <p><strong>Keyboard Shortcuts:</strong> Use <strong>Ctrl/Cmd + C, X, V</strong> for copy, cut, and paste. Use <strong>Delete/Backspace</strong> to delete selected items.</p>
            </div>
        </div>
    </div>

    <!-- Graph to LaTeX Tool Content -->
    <div id="content-graph-tool" class="flex flex-col h-full">
        <!-- Toolbar -->
        <div class="bg-gray-200 border-b border-gray-400 p-2 flex items-center flex-wrap gap-3 shadow-sm">
            <button id="select-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-fill" viewBox="0 0 16 16"><path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/></svg>Select</button>
            <button id="pan-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrows-move" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708l2-2zM8 10a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 14.293V10.5A.5.5 0 0 1 8 10zM.146 8.354a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708l-2-2zM10 8a.5.5 0 0 1 .5-.5h3.793l-1.147-1.146a.5.5 0 0 1 .708-.708l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L14.293 8.5H10.5A.5.5 0 0 1 10 8z"/></svg>Pan</button>
            <div class="w-px h-6 bg-gray-400 mx-2"></div>
            <button id="add-vertex-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>Add Vertex</button>
            <button id="add-edge-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><circle cx="3.5" cy="8" r="1.5" stroke="currentColor" stroke-width="1.5" fill="none"/><circle cx="12.5" cy="8" r="1.5" stroke="currentColor" stroke-width="1.5" fill="none"/><line x1="5" y1="8" x2="11" y2="8" stroke="currentColor" stroke-width="1.5"/></svg>Add Edge</button>
            <button id="delete-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6Z"/><path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1ZM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118ZM2.5 3h11V2h-11v1Z"/></svg>Delete</button>
            <div class="flex items-center gap-0 rounded-lg ring-1 ring-inset ring-gray-300 bg-white font-semibold shadow-sm"><span class="text-sm text-gray-600 px-3 py-1.5">Labels (l):</span><select id="auto-label-type" class="form-select !w-auto !py-1 !px-2 !text-sm !border-0 !ring-0 !rounded-r-lg !rounded-l-none focus:!ring-2 focus:!ring-blue-500 bg-white"><option value="numeric">1, 2, 3...</option><option value="alpha">a, b, c...</option><option value="off">Off</option></select></div>
            <div class="w-px h-6 bg-gray-400 mx-2"></div>
            <div class="relative inline-block text-left" id="align-menu-container">
                <div><button type="button" id="align-vertices-btn" class="btn btn-secondary" disabled>Align Vertices<svg class="-mr-1 ml-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button></div>
                <div id="align-options-dropdown" class="origin-top-left absolute left-0 mt-2 w-56 rounded-lg shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-10" role="menu" aria-orientation="vertical" aria-labelledby="align-vertices-btn">
                    <div class="py-1" role="none"><a href="#" id="align-vertical-btn" class="text-gray-700 block px-4 py-2 text-sm hover:bg-gray-100" role="menuitem">Align Vertically</a><a href="#" id="align-horizontal-btn" class="text-gray-700 block px-4 py-2 text-sm hover:bg-gray-100" role="menuitem">Align Horizontally</a></div>
                </div>
            </div>
            <button id="undo-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.408a.25.25 0 0 0 0 .384l2.36 2.066A.25.25 0 0 0 8 4.466z"/></svg>Undo</button>
            <button id="redo-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 2.066a.25.25 0 0 1 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>Redo</button>
            <div class="w-px h-6 bg-gray-400 mx-2"></div>
            <button id="download-svg-btn" class="btn btn-secondary">Download SVG</button>
            <button id="download-png-btn" class="btn btn-secondary">Download PNG</button>
            <button id="download-selected-svg-btn" class="btn btn-secondary" disabled>Download Selected SVG</button>
            <button id="download-selected-png-btn" class="btn btn-secondary" disabled>Download Selected PNG</button>
            <div class="flex-grow"></div>
            <button id="show-instructions-btn" class="btn btn-secondary">Show Instructions</button>
        </div>
        <div class="flex flex-grow overflow-hidden">
            <div class="flex-grow relative bg-white" id="canvas-wrapper">
                <svg id="canvas" class="w-full h-full"></svg>
                <div class="absolute bottom-4 right-4 flex flex-col gap-2">
                    <button id="zoom-in-btn" class="btn btn-secondary !p-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-zoom-in" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/><path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/><path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/></svg></button>
                    <button id="zoom-out-btn" class="btn btn-secondary !p-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-zoom-out" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/><path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/><path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/></svg></button>
                </div>
            </div>
            <aside id="properties-panel" class="w-72 bg-gray-100 border-l border-gray-300 p-4 overflow-y-auto transition-all duration-300 hidden">
                <div id="vertex-props" class="hidden space-y-4 relative">
                     <button id="close-vertex-props-btn" class="absolute top-0 right-0 text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                    <h3 class="text-lg font-semibold text-gray-800 border-b border-gray-200 pb-2">Vertex Properties</h3>
                    <div class="form-group"><label for="vertex-label">Label</label><input type="text" id="vertex-label" class="form-input"></div>
                    <div class="grid grid-cols-2 gap-4">
                        <div class="form-group"><label for="vertex-size">Size</label><select id="vertex-size" class="form-select"><option value="6">Small</option><option value="10" selected>Medium</option><option value="14">Large</option></select></div>
                        <div class="form-group"><label for="vertex-fill-type">Fill</label><select id="vertex-fill-type" class="form-select"><option value="solid">Solid</option><option value="empty">Empty</option></select></div>
                    </div>
                    <div class="form-group" id="vertex-color-group"><label for="vertex-color">Fill Color</label><input type="color" id="vertex-color" value="#628dc6" class="w-full h-10 p-1 border border-gray-300 bg-white rounded-lg"></div>
                    <div class="form-group"><label for="vertex-border">Border</label><select id="vertex-border" class="form-select"><option value="1">Thin</option><option value="1.5" selected>Normal</option><option value="2.5">Thick</option></select></div>
                    <button id="apply-to-all-vertices-btn" class="btn btn-primary w-full">Apply Styles to All Vertices</button>
                </div>
                <div id="edge-props" class="hidden space-y-4 relative">
                    <button id="close-edge-props-btn" class="absolute top-0 right-0 text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                    <h3 class="text-lg font-semibold text-gray-800 border-b border-gray-200 pb-2">Edge Properties</h3>
                    <div class="form-group"><label for="edge-type">Type</label><select id="edge-type" class="form-select"><option value="undirected">Undirected</option><option value="directed">Directed</option></select></div>
                    <div class="form-group"><label for="edge-style">Style</label><select id="edge-style" class="form-select"><option value="solid">Solid</option><option value="dashed">Dashed</option><option value="dotted">Dotted</option></select></div>
                    <div class="form-group flex items-center justify-center"><button id="reset-bend-btn" class="btn btn-secondary">Reset Bend</button></div>
                    <button id="apply-to-all-edges-btn" class="btn btn-primary w-full">Apply Styles to All Edges</button>
                </div>
                <div id="no-selection" class="text-center text-gray-500 mt-8"><p>Click an element on the canvas to see its properties.</p><p id="multi-select-info" class="hidden text-sm mt-2">Multiple items selected.</p></div>
            </aside>
        </div>
        <div class="h-56 flex flex-col border-t border-gray-400 bg-gray-100">
            <div class="p-2 flex justify-between items-center border-b border-gray-200 bg-white"><h3 class="text-md font-semibold text-gray-800 px-2">Generated TikZ Code</h3><button id="copy-button" class="btn btn-primary">Copy Code</button></div>
            <textarea id="tikz-code" readonly class="flex-grow w-full p-2 box-border border-none font-mono text-sm resize-none bg-white text-gray-800 focus:outline-none"></textarea>
            <div class="bg-white border-t border-gray-200 p-2 flex items-center gap-4 text-sm">
                <div class="flex items-center gap-2"><input type="checkbox" id="center-drawing-check" class="form-checkbox"><label for="center-drawing-check">Center Drawing</label></div>
                <div class="flex items-center gap-2"><input type="checkbox" id="add-caption-check" class="form-checkbox"><label for="add-caption-check" id="add-caption-label">Add Caption</label></div>
                <input type="text" id="caption-input" placeholder="Enter caption text..." class="form-input flex-grow text-sm py-1" disabled>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const svg = document.getElementById('canvas');
            const propertiesPanel = document.getElementById('properties-panel');
            const noSelectionPanel = document.getElementById('no-selection');
            const multiSelectInfo = document.getElementById('multi-select-info');
            const vertexPropsPanel = document.getElementById('vertex-props');
            const edgePropsPanel = document.getElementById('edge-props');
            const tikzCodeArea = document.getElementById('tikz-code');
            const NS = 'http://www.w3.org/2000/svg';

            let state = { vertices: [], edges: [], nextVertexId: 0, nextEdgeId: 0, selectedElements: [], mode: 'select', edgeStartVertex: null, autoLabelType: 'numeric', draggedElement: null, pan: {x: 0, y: 0}, zoom: 1 };
            let isMarqueeSelecting = false, marqueeRect = null, marqueeStartPoint = { x: 0, y: 0 }, clipboard = { vertices: [], edges: [] }, lastMouseCoords = { x: 0, y: 0 };
            let isPanning = false, panStartPoint = {x: 0, y: 0};
            let history = [], historyPointer = -1;
            const TIKZ_SCALE_FACTOR = 40;

            const selectModeBtn = document.getElementById('select-mode-btn');
            const panModeBtn = document.getElementById('pan-mode-btn');
            const addVertexBtn = document.getElementById('add-vertex-btn');
            const addEdgeBtn = document.getElementById('add-edge-btn');
            const deleteModeBtn = document.getElementById('delete-mode-btn');
            const alignVerticesBtn = document.getElementById('align-vertices-btn');
            const alignOptionsDropdown = document.getElementById('align-options-dropdown');
            const alignVerticalBtn = document.getElementById('align-vertical-btn');
            const alignHorizontalBtn = document.getElementById('align-horizontal-btn');
            const autoLabelTypeSelect = document.getElementById('auto-label-type');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const showInstructionsBtn = document.getElementById('show-instructions-btn');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsBtn = document.getElementById('close-instructions-btn');
            const copyBtn = document.getElementById('copy-button');
            const resetBendBtn = document.getElementById('reset-bend-btn');
            const centerCheck = document.getElementById('center-drawing-check');
            const captionCheck = document.getElementById('add-caption-check');
            const captionInput = document.getElementById('caption-input');
            const applyToAllVerticesBtn = document.getElementById('apply-to-all-vertices-btn');
            const applyToAllEdgesBtn = document.getElementById('apply-to-all-edges-btn');
            const downloadSvgBtn = document.getElementById('download-svg-btn');
            const downloadPngBtn = document.getElementById('download-png-btn');
            const downloadSelectedSvgBtn = document.getElementById('download-selected-svg-btn');
            const downloadSelectedPngBtn = document.getElementById('download-selected-png-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const closeVertexPropsBtn = document.getElementById('close-vertex-props-btn');
            const closeEdgePropsBtn = document.getElementById('close-edge-props-btn');
            
            const modeButtons = { 'select': selectModeBtn, 'pan': panModeBtn, 'addVertex': addVertexBtn, 'addEdge': addEdgeBtn, 'delete': deleteModeBtn };

            const vertexLabelInput = document.getElementById('vertex-label');
            const vertexSizeSelect = document.getElementById('vertex-size');
            const vertexFillTypeSelect = document.getElementById('vertex-fill-type');
            const vertexColorInput = document.getElementById('vertex-color');
            const vertexColorGroup = document.getElementById('vertex-color-group');
            const vertexBorderSelect = document.getElementById('vertex-border');
            const edgeTypeSelect = document.getElementById('edge-type');
            const edgeStyleSelect = document.getElementById('edge-style');

            function saveState() { history = history.slice(0, historyPointer + 1); history.push(JSON.parse(JSON.stringify(state))); historyPointer++; updateToolbarButtons(); }
            function undo() { if (historyPointer > 0) { historyPointer--; loadState(history[historyPointer]); } }
            function redo() { if (historyPointer < history.length - 1) { historyPointer++; loadState(history[historyPointer]); } }
            function loadState(newState) { state = JSON.parse(JSON.stringify(newState)); autoLabelTypeSelect.value = state.autoLabelType; setMode(state.mode, true); render(); updateToolbarButtons(); }
            function updateToolbarButtons() { undoBtn.disabled = historyPointer <= 0; redoBtn.disabled = historyPointer >= history.length - 1; const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex'); alignVerticesBtn.disabled = selectedVertices.length < 2; downloadSelectedSvgBtn.disabled = state.selectedElements.length === 0; downloadSelectedPngBtn.disabled = state.selectedElements.length === 0; }
            function getSVGCoords(evt) { const rect = svg.getBoundingClientRect(); const x = (evt.clientX - rect.left) / state.zoom + state.pan.x; const y = (evt.clientY - rect.top) / state.zoom + state.pan.y; return { x, y }; }
            function addVertex(x, y) { const newVertex = { id: state.nextVertexId++, x, y, label: '', radius: 10, fillType: 'solid', fillColor: '#628dc6', borderWidth: 1.5, borderColor: '#6b7280', type: 'vertex' }; const n = state.vertices.length; if (state.autoLabelType === 'numeric') newVertex.label = (n + 1).toString(); else if (state.autoLabelType === 'alpha') newVertex.label = String.fromCharCode(97 + n); state.vertices.push(newVertex); saveState(); selectElement(newVertex); render(); }
            function addEdge(sourceId, targetId) { if (sourceId === targetId || state.edges.some(e => (e.sourceId === sourceId && e.targetId === targetId) || (e.sourceId === targetId && e.targetId === sourceId))) return; const newEdge = { id: state.nextEdgeId++, sourceId, targetId, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } }; state.edges.push(newEdge); saveState(); }
            function deleteSelectedElements() { if (state.selectedElements.length === 0) return; const idsToDelete = new Set(state.selectedElements.map(el => el.id)); const typesToDelete = new Set(state.selectedElements.map(el => el.type)); if (typesToDelete.has('vertex')) { state.vertices = state.vertices.filter(v => !idsToDelete.has(v.id)); state.edges = state.edges.filter(e => !idsToDelete.has(e.sourceId) && !idsToDelete.has(e.targetId)); } if (typesToDelete.has('edge')) { state.edges = state.edges.filter(e => !idsToDelete.has(e.id)); } selectElement(null); saveState(); render(); }
            function alignSelectedVertices(alignmentType) { const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex'); if (selectedVertices.length < 2) return; let avgX = 0, avgY = 0; selectedVertices.forEach(v => { avgX += v.x; avgY += v.y; }); avgX /= selectedVertices.length; avgY /= selectedVertices.length; const selectedIds = new Set(selectedVertices.map(v => v.id)); state.vertices.forEach(v => { if (selectedIds.has(v.id)) { if (alignmentType === 'horizontal') v.y = avgY; if (alignmentType === 'vertical') v.x = avgX; } }); state.edges.forEach(edge => { if (edge.controlPoint.isDefault) { const source = state.vertices.find(v => v.id === edge.sourceId), target = state.vertices.find(v => v.id === edge.targetId); if (source && target) { edge.controlPoint.x = (source.x + target.x) / 2; edge.controlPoint.y = (source.y + target.y) / 2; } } }); saveState(); render(); }
            function copySelection() { if (state.selectedElements.length === 0) return; const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex'); const selectedEdges = state.selectedElements.filter(el => el.type === 'edge'); clipboard.vertices = JSON.parse(JSON.stringify(selectedVertices)); clipboard.edges = JSON.parse(JSON.stringify(selectedEdges)); }
            function pasteFromClipboard() { if (clipboard.vertices.length === 0 && clipboard.edges.length === 0) return; const oldToNewIdMap = new Map(), newSelection = []; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if (clipboard.vertices.length > 0) { clipboard.vertices.forEach(v => { minX = Math.min(minX, v.x); minY = Math.min(minY, v.y); maxX = Math.max(maxX, v.x); maxY = Math.max(maxY, v.y); }); } else { minX = lastMouseCoords.x; maxX = lastMouseCoords.x; minY = lastMouseCoords.y; maxY = lastMouseCoords.y; } const selectionCenterX = (minX + maxX) / 2, selectionCenterY = (minY + maxY) / 2; const offsetX = lastMouseCoords.x - selectionCenterX, offsetY = lastMouseCoords.y - selectionCenterY; clipboard.vertices.forEach(v => { const oldId = v.id; const newVertex = JSON.parse(JSON.stringify(v)); newVertex.id = state.nextVertexId++; newVertex.x += offsetX; newVertex.y += offsetY; state.vertices.push(newVertex); oldToNewIdMap.set(oldId, newVertex.id); newSelection.push(newVertex); }); clipboard.edges.forEach(e => { const newEdge = JSON.parse(JSON.stringify(e)); newEdge.id = state.nextEdgeId++; newEdge.sourceId = oldToNewIdMap.get(e.sourceId); newEdge.targetId = oldToNewIdMap.get(e.targetId); if (newEdge.sourceId !== undefined && newEdge.targetId !== undefined) { if (!e.controlPoint.isDefault) { newEdge.controlPoint.x += offsetX; newEdge.controlPoint.y += offsetY; } state.edges.push(newEdge); newSelection.push(newEdge); } }); state.selectedElements = newSelection; updatePropertiesPanel(); saveState(); render(); }
            function setMode(newMode, fromLoad = false) { if (!fromLoad && state.mode === newMode) newMode = 'select'; state.mode = newMode; Object.values(modeButtons).forEach(btn => btn.classList.remove('active')); if (modeButtons[state.mode]) modeButtons[state.mode].classList.add('active'); svg.style.cursor = { 'pan': 'grab', 'addVertex': 'crosshair', 'addEdge': 'pointer', 'delete': 'pointer' }[state.mode] || 'default'; state.edgeStartVertex = null; render(); }
            function selectElement(element, isMultiSelect = false) { if (isMultiSelect) { const index = state.selectedElements.findIndex(el => el.id === element.id && el.type === element.type); if (index > -1) state.selectedElements.splice(index, 1); else state.selectedElements.push(element); } else { state.selectedElements = element ? [element] : []; } updatePropertiesPanel(); updateToolbarButtons(); }
            function updatePropertiesPanel() { const selectedCount = state.selectedElements.length; propertiesPanel.classList.toggle('hidden', selectedCount === 0); noSelectionPanel.classList.toggle('hidden', selectedCount > 0); multiSelectInfo.classList.toggle('hidden', selectedCount <= 1); vertexPropsPanel.classList.add('hidden'); edgePropsPanel.classList.add('hidden'); if (selectedCount === 1) { const selected = state.selectedElements[0]; if (selected.type === 'vertex') { vertexPropsPanel.classList.remove('hidden'); const v = selected; vertexLabelInput.value = v.label; vertexSizeSelect.value = v.radius; vertexFillTypeSelect.value = v.fillType; vertexColorInput.value = v.fillColor; vertexBorderSelect.value = v.borderWidth; vertexColorGroup.style.display = v.fillType === 'solid' ? 'block' : 'none'; } else if (selected.type === 'edge') { edgePropsPanel.classList.remove('hidden'); const e = selected; edgeTypeSelect.value = e.edgeType; edgeStyleSelect.value = e.lineStyle; } } }
            
            function render() {
                const { width, height } = svg.getBoundingClientRect();
                svg.setAttribute('viewBox', `${state.pan.x} ${state.pan.y} ${width / state.zoom} ${height / state.zoom}`);
                svg.innerHTML = ''; // Clear previous render
                const defs = document.createElementNS(NS, 'defs');

                const markerDefault = document.createElementNS(NS, 'marker');
                markerDefault.setAttribute('id', 'arrowhead-default');
                markerDefault.setAttribute('viewBox', '0 -1.5 2.5 3'); 
                markerDefault.setAttribute('refX', '2'); 
                markerDefault.setAttribute('refY', '0');
                markerDefault.setAttribute('markerWidth', '2'); 
                markerDefault.setAttribute('markerHeight', '2');
                markerDefault.setAttribute('orient', 'auto');
                const pathDefault = document.createElementNS(NS, 'path');
                pathDefault.setAttribute('d', 'M0,-1L2,0L0,1');
                pathDefault.setAttribute('fill', 'currentColor');
                markerDefault.appendChild(pathDefault);
                defs.appendChild(markerDefault);

                const markerSelected = document.createElementNS(NS, 'marker');
                markerSelected.setAttribute('id', 'arrowhead-selected');
                markerSelected.setAttribute('viewBox', '-2 -5 10 10');
                markerSelected.setAttribute('refX', '8');
                markerSelected.setAttribute('refY', '0');
                markerSelected.setAttribute('markerWidth', '6');
                markerSelected.setAttribute('markerHeight', '6');
                markerSelected.setAttribute('orient', 'auto');
                const pathSelected = document.createElementNS(NS, 'path');
                pathSelected.setAttribute('d', 'M0,-4L8,0L0,4');
                pathSelected.setAttribute('fill', 'currentColor');
                markerSelected.appendChild(pathSelected);
                defs.appendChild(markerSelected);

                svg.appendChild(defs);

                const isSelected = (el) => state.selectedElements.some(sel => sel.id === el.id && sel.type === el.type);
                
                state.edges.forEach(edge => {
                    const source = state.vertices.find(v => v.id === edge.sourceId);
                    const target = state.vertices.find(v => v.id === edge.targetId);
                    if (!source || !target) return;
                    
                    const g = document.createElementNS(NS, 'g');
                    g.classList.add('edge');
                    if (isSelected(edge)) g.classList.add('selected');
                    
                    if (edge.controlPoint.isDefault) {
                        edge.controlPoint.x = (source.x + target.x) / 2;
                        edge.controlPoint.y = (source.y + target.y) / 2;
                    }
                    
                    const pathEl = document.createElementNS(NS, 'path');
                    pathEl.classList.add('edge-path');

                    const getBorderPoint = (from, to, vertex) => {
                        let dx = to.x - from.x;
                        let dy = to.y - from.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len === 0) return to;
                        const offset = parseFloat(vertex.radius) + (parseFloat(vertex.borderWidth) / 2);
                        return {
                            x: to.x - (dx / len) * offset,
                            y: to.y - (dy / len) * offset
                        };
                    };

                    const controlPoint = edge.controlPoint.isDefault ? { x: (source.x + target.x) / 2, y: (source.y + target.y) / 2 } : edge.controlPoint;
                    
                    const finalSource = getBorderPoint(controlPoint, source, source);
                    const finalTarget = getBorderPoint(controlPoint, target, target);

                    pathEl.setAttribute('d', `M ${finalSource.x} ${finalSource.y} Q ${controlPoint.x} ${controlPoint.y} ${finalTarget.x} ${finalTarget.y}`);
                    
                    if (edge.lineStyle === 'dashed') pathEl.style.strokeDasharray = '5,5';
                    if (edge.lineStyle === 'dotted') pathEl.style.strokeDasharray = '1.5,4';
                    
                    if (edge.edgeType === 'directed') {
                        pathEl.setAttribute('marker-end', isSelected(edge) ? 'url(#arrowhead-selected)' : 'url(#arrowhead-default)');
                    }
                    
                    const interactionArea = pathEl.cloneNode();
                    interactionArea.classList.add('edge-interaction-area');
                    g.appendChild(pathEl);
                    g.appendChild(interactionArea);
                    
                    interactionArea.addEventListener('mousedown', (e) => { e.stopPropagation(); if (state.mode === 'delete') deleteSelectedElements(); else { selectElement(edge, e.shiftKey); render(); } });
                    interactionArea.addEventListener('mouseenter', () => { g.classList.add('hovered'); if (state.mode === 'delete') g.classList.add('delete-mode-hover'); });
                    interactionArea.addEventListener('mouseleave', () => g.classList.remove('hovered', 'delete-mode-hover'));
                    
                    const handle = document.createElementNS(NS, 'circle');
                    handle.classList.add('edge-handle');
                    handle.setAttribute('cx', edge.controlPoint.x);
                    handle.setAttribute('cy', edge.controlPoint.y);
                    handle.setAttribute('r', '6');
                    handle.addEventListener('mousedown', (e) => { e.stopPropagation(); state.draggedElement = { type: 'handle', edgeId: edge.id }; });
                    
                    g.appendChild(handle);
                    svg.appendChild(g);
                });

                state.vertices.forEach(vertex => {
                    const g = document.createElementNS(NS, 'g');
                    g.classList.add('vertex');
                    g.setAttribute('transform', `translate(${vertex.x}, ${vertex.y})`);
                    if (isSelected(vertex)) g.classList.add('selected');
                    if (state.edgeStartVertex && state.edgeStartVertex.id === vertex.id) g.classList.add('edge-start');
                    
                    const circle = document.createElementNS(NS, 'circle');
                    circle.classList.add('vertex-shape');
                    circle.setAttribute('r', vertex.radius);
                    circle.style.fill = vertex.fillType === 'solid' ? vertex.fillColor : 'transparent';
                    circle.style.stroke = vertex.borderColor;
                    circle.style.strokeWidth = vertex.borderWidth;
                    
                    const label = document.createElementNS(NS, 'text');
                    label.classList.add('vertex-label');
                    label.textContent = vertex.label;
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('dy', '.3em');
                    
                    g.appendChild(circle);
                    g.appendChild(label);
                    
                    g.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        if (state.mode === 'addEdge') {
                            if (!state.edgeStartVertex) { state.edgeStartVertex = vertex; render(); } 
                            else { addEdge(state.edgeStartVertex.id, vertex.id); state.edgeStartVertex = null; render(); }
                        } else if (state.mode === 'delete') {
                            selectElement(vertex, e.shiftKey);
                            deleteSelectedElements();
                        } else {
                            state.draggedElement = { type: 'vertex', id: vertex.id, startX: e.clientX, startY: e.clientY };
                            if (!isSelected(vertex)) { selectElement(vertex, e.shiftKey); }
                            render();
                        }
                    });
                    g.addEventListener('mouseenter', () => { g.classList.add('hovered'); if (state.mode === 'delete') g.classList.add('delete-mode-hover'); });
                    g.addEventListener('mouseleave', () => g.classList.remove('hovered', 'delete-mode-hover'));
                    svg.appendChild(g);
                });

                if (marqueeRect) { svg.appendChild(marqueeRect); }
                generateTikZ();
            }

            function generateTikZ() { const doCenter = centerCheck.checked, doCaption = captionCheck.checked, captionText = captionInput.value; const hexToName = {}; let colorIndex = 0; state.vertices.forEach(v => { if (!hexToName[v.borderColor]) hexToName[v.borderColor] = `mycolor${colorIndex++}`; if (v.fillType === 'solid' && !hexToName[v.fillColor]) hexToName[v.fillColor] = `mycolor${colorIndex++}`; }); let code = ''; for (const hex in hexToName) code += `\\definecolor{${hexToName[hex]}}{HTML}{${hex.substring(1)}}\n`; if (doCenter || doCaption) code += `\\begin{figure}[h!]\n${doCenter ? '  \\centering\n' : ''}`; code += '  \\begin{tikzpicture}[every node/.style={draw, circle}]\n'; const canvasHeight = svg.getBoundingClientRect().height; const tikzBorder = { 1: 'thin', 1.5: '', 2.5: 'thick' }; const sizeMap = { 6: '0.4cm', 10: '0.6cm', 14: '0.8cm' }; code += '    % Vertices\n'; state.vertices.forEach(v => { const x = (v.x / TIKZ_SCALE_FACTOR).toFixed(2), y = ((canvasHeight - v.y) / TIKZ_SCALE_FACTOR).toFixed(2); let styles = [`draw=${hexToName[v.borderColor]}`]; if (v.fillType === 'solid') styles.push(`fill=${hexToName[v.fillColor]}`); else styles.push('fill=none'); styles.push(`minimum size=${sizeMap[v.radius]}`); if (tikzBorder[v.borderWidth]) styles.push(tikzBorder[v.borderWidth]); code += `    \\node[${styles.join(', ')}] (v${v.id}) at (${x}, ${y}) {${v.label}};\n`; }); code += '\n    % Edges\n'; state.edges.forEach(e => { let styles = []; if (e.edgeType === 'directed') styles.push('-{stealth}'); if (e.lineStyle === 'dashed') styles.push('dashed'); if (e.lineStyle === 'dotted') styles.push('dotted'); const styleString = styles.length > 0 ? `[${styles.join(', ')}]` : ''; const source = state.vertices.find(v => v.id === e.sourceId), target = state.vertices.find(v => v.id === e.targetId); if (!source || !target) return; const isBent = Math.sqrt((e.controlPoint.x - (source.x + target.x)/2)**2 + (e.controlPoint.y - (source.y + target.y)/2)**2) > 2; if (isBent) { const cx = (e.controlPoint.x / TIKZ_SCALE_FACTOR).toFixed(2), cy = ((canvasHeight - e.controlPoint.y) / TIKZ_SCALE_FACTOR).toFixed(2); code += `    \\draw${styleString} (v${e.sourceId}) .. controls (${cx},${cy}) .. (v${e.targetId});\n`; } else code += `    \\draw${styleString} (v${e.sourceId}) -- (v${e.targetId});\n`; }); code += '  \\end{tikzpicture}'; if (doCenter || doCaption) { if (doCaption && captionText) code += `\n  \\caption{${captionText}}\n`; code += '\\end{figure}'; } tikzCodeArea.value = code; }

            function getBoundingBox(elements) {
                const vertices = elements.filter(el => el.type === 'vertex');
                if (vertices.length === 0) return null;

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                vertices.forEach(v => {
                    minX = Math.min(minX, v.x - v.radius);
                    minY = Math.min(minY, v.y - v.radius);
                    maxX = Math.max(maxX, v.x + v.radius);
                    maxY = Math.max(maxY, v.y + v.radius);
                });
                return { minX, minY, maxX, maxY };
            }

            function downloadImage(isPng, selectedOnly) {
                const elementsToExport = selectedOnly ? state.selectedElements : [...state.vertices, ...state.edges];
                const verticesToConsider = selectedOnly ? elementsToExport.filter(el => el.type === 'vertex') : state.vertices;

                if (verticesToConsider.length === 0) {
                    console.warn("Cannot export an empty or edge-only selection.");
                    return;
                }

                const bbox = getBoundingBox(verticesToConsider);
                const padding = 20;
                const contentWidth = bbox.maxX - bbox.minX + padding * 2;
                const contentHeight = bbox.maxY - bbox.minY + padding * 2;
                
                const svgData = getSVGForExport(elementsToExport);
                const finalSVGData = svgData.replace(/<svg[^>]+>/, `<svg width="${contentWidth}" height="${contentHeight}" viewBox="${bbox.minX - padding} ${bbox.minY - padding} ${contentWidth} ${contentHeight}" xmlns="http://www.w3.org/2000/svg">`);
                
                const blob = new Blob([finalSVGData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                if (isPng) {
                    const canvasEl = document.createElement('canvas');
                    const scale = 2;
                    canvasEl.width = contentWidth * scale;
                    canvasEl.height = contentHeight * scale;
                    const ctx = canvasEl.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

                    const img = new Image();
                    img.onload = function () {
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(url);
                        const a = document.createElement('a');
                        a.href = canvasEl.toDataURL('image/png');
                        a.download = selectedOnly ? 'graph-selection.png' : 'graph.png';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    };
                    img.src = url;
                } else {
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = selectedOnly ? 'graph-selection.svg' : 'graph.svg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            function getSVGForExport(elements) {
                // This function should ideally build an SVG string from the provided elements
                // For simplicity, we'll use the current state but this is where you'd filter.
                const svgClone = svg.cloneNode(true);
                svgClone.querySelectorAll('.edge-handle, .edge-interaction-area, .marquee-rect').forEach(el => el.remove());
                const cssStyles = `
                    .vertex-label { font-family: 'Inter', sans-serif; font-size: 12px; fill: #1d2129; }
                    .edge-path { fill: none; stroke: #6b7280; color: #6b7280; stroke-width: 1.5px; }
                    .edge.selected .edge-path { stroke: #f59e0b !important; stroke-width: 3.5px !important; color: #f59e0b !important; }
                `;
                const styleEl = document.createElementNS(NS, 'style');
                styleEl.textContent = cssStyles;
                const defs = svgClone.querySelector('defs') || svgClone.insertBefore(document.createElementNS(NS, 'defs'), svgClone.firstChild);
                defs.insertBefore(styleEl, defs.firstChild);
                return new XMLSerializer().serializeToString(svgClone);
            }

            function zoomCanvas(direction, mouseX, mouseY) {
                const { width, height } = svg.getBoundingClientRect();
                const zoomFactor = direction === 'in' ? 1.2 : 1 / 1.2;
                const newZoom = Math.max(0.1, Math.min(10, state.zoom * zoomFactor));

                const screenX = mouseX - svg.getBoundingClientRect().left;
                const screenY = mouseY - svg.getBoundingClientRect().top;
                
                const worldXBefore = (screenX / state.zoom) + state.pan.x;
                const worldYBefore = (screenY / state.zoom) + state.pan.y;

                const worldXAfter = (screenX / newZoom) + state.pan.x;
                const worldYAfter = (screenY / newZoom) + state.pan.y;

                state.pan.x += worldXBefore - worldXAfter;
                state.pan.y += worldYBefore - worldYAfter;
                state.zoom = newZoom;
                
                render();
            }

            // Event Listeners
            selectModeBtn.addEventListener('click', () => setMode('select'));
            panModeBtn.addEventListener('click', () => setMode('pan'));
            addVertexBtn.addEventListener('click', () => setMode('addVertex'));
            addEdgeBtn.addEventListener('click', () => setMode('addEdge'));
            deleteModeBtn.addEventListener('click', () => setMode('delete'));
            alignVerticesBtn.addEventListener('click', (e) => { e.stopPropagation(); alignOptionsDropdown.classList.toggle('hidden'); });
            alignVerticalBtn.addEventListener('click', (e) => { e.preventDefault(); alignSelectedVertices('vertical'); alignOptionsDropdown.classList.add('hidden'); });
            alignHorizontalBtn.addEventListener('click', (e) => { e.preventDefault(); alignSelectedVertices('horizontal'); alignOptionsDropdown.classList.add('hidden'); });
            window.addEventListener('click', () => { if (!alignOptionsDropdown.classList.contains('hidden')) { alignOptionsDropdown.classList.add('hidden'); } });
            autoLabelTypeSelect.addEventListener('change', (e) => { state.autoLabelType = e.target.value; if (state.selectedElements.some(el => el.type === 'vertex')) { state.vertices.forEach((vertex, i) => { if (state.autoLabelType === 'numeric') { vertex.label = (i + 1).toString(); } else if (state.autoLabelType === 'alpha') { vertex.label = String.fromCharCode(97 + i); } else { vertex.label = ''; } }); saveState(); render(); } });
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            showInstructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
            closeInstructionsBtn.addEventListener('click', () => instructionsModal.classList.add('hidden'));
            instructionsModal.addEventListener('click', (e) => { if (e.target === instructionsModal) instructionsModal.classList.add('hidden'); });
            copyBtn.addEventListener('click', () => { tikzCodeArea.select(); document.execCommand('copy'); copyBtn.textContent = 'Copied!'; setTimeout(() => { copyBtn.textContent = 'Copy Code'; }, 2000); });
            resetBendBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'edge') { state.selectedElements[0].controlPoint.isDefault = true; saveState(); render(); } });
            applyToAllVerticesBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'vertex') { const style = state.selectedElements[0]; state.vertices.forEach(v => { v.radius = style.radius; v.fillType = style.fillType; v.fillColor = style.fillColor; v.borderWidth = style.borderWidth; v.borderColor = style.borderColor; }); saveState(); render(); } });
            applyToAllEdgesBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'edge') { const style = state.selectedElements[0]; state.edges.forEach(e => { e.edgeType = style.edgeType; e.lineStyle = style.lineStyle; }); saveState(); render(); } });
            centerCheck.addEventListener('change', generateTikZ);
            captionCheck.addEventListener('change', () => { captionInput.disabled = !captionCheck.checked; generateTikZ(); });
            captionInput.addEventListener('input', generateTikZ);
            
            downloadSvgBtn.addEventListener('click', () => downloadImage(false, false));
            downloadPngBtn.addEventListener('click', () => downloadImage(true, false));
            downloadSelectedSvgBtn.addEventListener('click', () => downloadImage(false, true));
            downloadSelectedPngBtn.addEventListener('click', () => downloadImage(true, true));
            
            zoomInBtn.addEventListener('click', () => { const { width, height } = svg.getBoundingClientRect(); zoomCanvas('in', width / 2, height / 2); });
            zoomOutBtn.addEventListener('click', () => { const { width, height } = svg.getBoundingClientRect(); zoomCanvas('out', width / 2, height / 2); });
            closeVertexPropsBtn.addEventListener('click', () => propertiesPanel.classList.add('hidden'));
            closeEdgePropsBtn.addEventListener('click', () => propertiesPanel.classList.add('hidden'));

            svg.addEventListener('wheel', (e) => { e.preventDefault(); zoomCanvas(e.deltaY < 0 ? 'in' : 'out', e.clientX, e.clientY); });

            svg.addEventListener('mousedown', (e) => {
                if (e.target !== svg) return;
                if (state.mode === 'pan') {
                    isPanning = true;
                    panStartPoint = { x: e.clientX, y: e.clientY };
                } else if (state.mode === 'addVertex') {
                    const coords = getSVGCoords(e);
                    addVertex(coords.x, coords.y);
                } else if (state.mode === 'select') {
                    isMarqueeSelecting = true;
                    marqueeStartPoint = getSVGCoords(e);
                    marqueeRect = document.createElementNS(NS, 'rect');
                    marqueeRect.classList.add('marquee-rect');
                    marqueeRect.setAttribute('x', marqueeStartPoint.x);
                    marqueeRect.setAttribute('y', marqueeStartPoint.y);
                    marqueeRect.setAttribute('width', 0);
                    marqueeRect.setAttribute('height', 0);
                    svg.appendChild(marqueeRect);
                }
            });

            window.addEventListener('mousemove', (e) => {
                const coords = getSVGCoords(e);
                lastMouseCoords = coords;
                if (isPanning) {
                    const dx = (e.clientX - panStartPoint.x) / state.zoom;
                    const dy = (e.clientY - panStartPoint.y) / state.zoom;
                    state.pan.x -= dx;
                    state.pan.y -= dy;
                    panStartPoint = { x: e.clientX, y: e.clientY };
                    render();
                    return;
                }
                if (isMarqueeSelecting && marqueeRect) { const x = Math.min(coords.x, marqueeStartPoint.x), y = Math.min(coords.y, marqueeStartPoint.y), width = Math.abs(coords.x - marqueeStartPoint.x), height = Math.abs(coords.y - marqueeStartPoint.y); marqueeRect.setAttribute('x', x); marqueeRect.setAttribute('y', y); marqueeRect.setAttribute('width', width); marqueeRect.setAttribute('height', height); return; }
                if (!state.draggedElement) return;
                
                if (state.draggedElement.type === 'vertex') {
                    const dx = (e.clientX - state.draggedElement.startX) / state.zoom;
                    const dy = (e.clientY - state.draggedElement.startY) / state.zoom;
                    
                    const selectedVertexIds = new Set(state.selectedElements.filter(el => el.type === 'vertex').map(v => v.id));
                    if (!selectedVertexIds.has(state.draggedElement.id)) {
                        const draggedVertex = state.vertices.find(v => v.id === state.draggedElement.id);
                        draggedVertex.x += dx;
                        draggedVertex.y += dy;
                    } else {
                        state.vertices.forEach(v => { if (selectedVertexIds.has(v.id)) { v.x += dx; v.y += dy; } });
                    }
                    state.draggedElement.startX = e.clientX;
                    state.draggedElement.startY = e.clientY;
                } else if (state.draggedElement.type === 'handle') {
                    const edge = state.edges.find(e => e.id === state.draggedElement.edgeId);
                    if (edge) { edge.controlPoint.x = coords.x; edge.controlPoint.y = coords.y; edge.controlPoint.isDefault = false; }
                }
                render();
            });

            window.addEventListener('mouseup', (e) => {
                isPanning = false;
                if (isMarqueeSelecting && marqueeRect) {
                    const x = parseFloat(marqueeRect.getAttribute('x')), y = parseFloat(marqueeRect.getAttribute('y')), width = parseFloat(marqueeRect.getAttribute('width')), height = parseFloat(marqueeRect.getAttribute('height'));
                    const selectedInBox = state.vertices.filter(v => v.x >= x && v.x <= x + width && v.y >= y && v.y <= y + height);
                    
                    if (e.shiftKey) {
                        selectedInBox.forEach(item => { if (!state.selectedElements.some(sel => sel.type === item.type && sel.id === item.id)) { state.selectedElements.push(item); } });
                    } else {
                        state.selectedElements = selectedInBox;
                    }
                    marqueeRect.remove();
                    marqueeRect = null;
                    isMarqueeSelecting = false;
                    updatePropertiesPanel();
                    updateToolbarButtons();
                    render();
                }
                if (state.draggedElement) {
                    if (state.draggedElement.type === 'vertex') {
                        saveState();
                    } else if (state.draggedElement.type === 'handle') {
                        saveState();
                    }
                    state.draggedElement = null;
                    render();
                }
            });

            window.addEventListener('keydown', (e) => { if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; const isCtrlOrMeta = e.ctrlKey || e.metaKey; if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedElements(); else if (e.key === 'Escape') { setMode('select'); selectElement(null); render(); } else if (e.key === 'e' && !isCtrlOrMeta) { e.preventDefault(); addEdgeBtn.click(); } else if (e.key === 'l' && !isCtrlOrMeta) { e.preventDefault(); const opts = Array.from(autoLabelTypeSelect.options); const curIdx = opts.findIndex(opt => opt.value === state.autoLabelType); autoLabelTypeSelect.value = opts[(curIdx + 1) % opts.length].value; autoLabelTypeSelect.dispatchEvent(new Event('change')); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'c') { e.preventDefault(); copySelection(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'x') { e.preventDefault(); copySelection(); deleteSelectedElements(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'v') { e.preventDefault(); pasteFromClipboard(); } });
            
            const inputs = [vertexLabelInput, vertexSizeSelect, vertexFillTypeSelect, vertexColorInput, vertexBorderSelect, edgeTypeSelect, edgeStyleSelect];
            inputs.forEach(input => { input.addEventListener('change', (e) => { if (state.selectedElements.length !== 1) return; const el = state.selectedElements[0]; switch (e.target.id) { case 'vertex-label': el.label = e.target.value; break; case 'vertex-size': el.radius = parseInt(e.target.value); break; case 'vertex-fill-type': el.fillType = e.target.value; vertexColorGroup.style.display = el.fillType === 'solid' ? 'block' : 'none'; break; case 'vertex-color': el.fillColor = e.target.value; break; case 'vertex-border': el.borderWidth = parseFloat(e.target.value); break; case 'edge-type': el.edgeType = e.target.value; break; case 'edge-style': el.lineStyle = e.target.value; break; } saveState(); render(); }); });

            saveState();
            setMode('select');
        });
    </script>

</body>
</html>
