<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph to LaTeX Exporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <style>
        :root {
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-light: #94a3b8;
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --border-color-light: #e2e8f0;
            --border-color-dark: #cbd5e1;
            --background-light: #f8fafc;
            --background-white: #ffffff;
        }

        * { box-sizing: border-box; }

        body {
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: radial-gradient(circle at 10% 20%, rgba(37, 99, 235, 0.08), transparent 25%),
                        radial-gradient(circle at 80% 0%, rgba(16, 185, 129, 0.08), transparent 20%),
                        var(--background-light);
            color: var(--text-primary);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.55rem 0.8rem;
            font-weight: 600;
            font-size: 0.85rem;
            border-radius: 0.65rem;
            transition: all 0.15s ease;
            border: 1px solid transparent;
            cursor: pointer;
            outline: none;
        }

        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--primary-color); color: var(--background-white); box-shadow: 0 10px 30px rgba(37, 99, 235, 0.22); }
        .btn-primary:hover { background-color: var(--primary-hover); }

        .btn-secondary { background-color: var(--background-white); color: var(--text-secondary); border-color: var(--border-color-light); }
        .btn-secondary:hover { background-color: #eef2ff; border-color: #c7d2fe; color: #3730a3; }

        .btn.active { background-color: #1f2937; color: white; border-color: #111827; box-shadow: inset 0 1px 0 rgba(255,255,255,0.1); }

        .form-input, .form-select {
            width: 100%;
            padding: 0.5rem 0.7rem;
            border-radius: 0.6rem;
            border: 1px solid var(--border-color-dark);
            background: var(--background-white);
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }

        .form-input:focus, .form-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.18);
            outline: none;
        }

        .form-checkbox {
            width: 1rem;
            height: 1rem;
            accent-color: var(--primary-color);
        }

        .vertex { cursor: move; }
        .vertex-label { pointer-events: none; user-select: none; font-size: 12px; fill: var(--text-primary); font-family: var(--font-family); }
        .edge, .edge-handle { cursor: pointer; }
        .edge-path {
            fill: none;
            stroke: var(--text-secondary);
            color: var(--text-secondary);
            stroke-width: 1.5px;
        }
        .edge-interaction-area { stroke-width: 12; stroke: transparent; fill: none; }
        .edge-handle { fill: var(--primary-color); opacity: 0.8; transition: transform 0.2s, opacity 0.2s; }
        .edge-handle:hover { opacity: 1; transform: scale(1.05); }
        .vertex.selected .vertex-shape, .edge.selected .edge-path { stroke: var(--warning-color) !important; stroke-width: 3.5px !important; color: var(--warning-color) !important; }
        .vertex.hovered .vertex-shape, .edge.hovered .edge-path { stroke: var(--primary-color) !important; stroke-width: 2.5px !important; color: var(--primary-color) !important; }
        .vertex.edge-start .vertex-shape { animation: pulse 1.5s infinite; }
        .marquee-rect { fill: rgba(37, 99, 235, 0.12); stroke: rgba(37, 99, 235, 0.7); stroke-width: 1px; stroke-dasharray: 3,3; }
        .edge-angle-text { font-family: var(--font-family); font-size: 10px; fill: var(--text-secondary); pointer-events: none; user-select: none; text-anchor: middle; }
        #canvas { cursor: grab; }
        #canvas:active { cursor: grabbing; }
        @keyframes pulse { 0% { stroke-width: 1.5px; } 50% { stroke-width: 4px; stroke: var(--primary-color); } 100% { stroke-width: 1.5px; } }

        .panel-card {
            background: rgba(255,255,255,0.92);
            border: 1px solid var(--border-color-light);
            border-radius: 1rem;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
            overflow: hidden;
        }

        .toolbar-group { gap: 0.4rem; }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.7rem;
            background: #e0f2fe;
            color: #075985;
            border-radius: 999px;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .status-dot { width: 10px; height: 10px; background: var(--primary-color); border-radius: 999px; box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.2); }
    </style>
</head>
<body class="text-slate-700">

    <!-- Instructions Popup -->
    <div id="instructions-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center px-4">
        <div class="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-2xl relative border border-slate-200">
            <button id="close-instructions-btn" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
            <h3 class="text-xl font-semibold mb-3">How to use the graph editor</h3>
            <div class="text-sm space-y-2 text-gray-700 leading-relaxed">
                <p><strong>To add a vertex:</strong> Turn on <strong>Add Vertex</strong>, then click anywhere on the canvas.</p>
                <p><strong>To add an edge:</strong> Turn on <strong>Add Edge</strong>, then click the source vertex followed by the target vertex.</p>
                <p><strong>To select items:</strong> Turn on <strong>Select</strong> mode. Click an item. Hold <strong>Shift</strong> while clicking to select multiple items. Click and drag on the background to select items in an area.</p>
                <p><strong>To align vertices:</strong> Select two or more vertices, click the <strong>Align Vertices</strong> dropdown, and choose an alignment.</p>
                <p><strong>To navigate the canvas:</strong> Turn on <strong>Pan</strong> mode. Click and drag the background to pan. Use the mouse wheel to zoom in and out.</p>
                <p><strong>Keyboard Shortcuts:</strong> Use <strong>Ctrl/Cmd + C, X, V</strong> for copy, cut, and paste. Use <strong>Delete/Backspace</strong> to delete selected items.</p>
            </div>
        </div>
    </div>

    <div class="max-w-7xl mx-auto w-full h-screen px-4 lg:px-6 py-6 flex flex-col gap-4">
        <header class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
            <div class="space-y-2">
                <div class="pill w-fit">
                    <span class="status-dot"></span>
                    <span>Graph to LaTeX Exporter</span>
                </div>
                <div>
                    <h1 class="text-3xl font-semibold text-slate-900">Interactive Graph Editor</h1>
                    <p class="text-sm text-slate-500">Build graphs visually, fine-tune styling, and export both SVG/PNG and TikZ snippets.</p>
                </div>
            </div>
            <div class="flex items-center gap-3 flex-wrap">
                <div class="pill bg-slate-900 text-white">
                    <span class="text-xs uppercase tracking-wide text-slate-300">Current mode</span>
                    <span id="active-mode-label" class="font-semibold">Select</span>
                </div>
                <button id="show-instructions-btn" class="btn btn-secondary">Show Tips</button>
            </div>
        </header>

        <div class="panel-card flex flex-col gap-0 flex-1">
            <div class="bg-white/80 border-b border-slate-200 px-3 py-3 flex flex-wrap items-center gap-2 toolbar-group">
                <div class="flex flex-wrap items-center gap-2">
                    <button id="select-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-fill" viewBox="0 0 16 16"><path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/></svg>Select</button>
                    <button id="pan-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrows-move" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 1 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708l2-2zM7.646 15.854a.5.5 0 0 1 .708 0l2-2a.5.5 0 1 0-.708-.708L8.5 14.293V10.5a.5.5 0 0 0-1 0v3.793l-1.146-1.147a.5.5 0 1 0-.708.708l2 2zM.146 7.646a.5.5 0 0 1 .708 0l2 2a.5.5 0 1 1-.708.708L1.707 8.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 1 1-.708.708l-2-2a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708l-2-2a.5.5 0 0 1 0-.708zM15.854 7.646a.5.5 0 0 0 0 .708l-2 2a.5.5 0 1 0 .708.708l1.147-1.146V8.5H10.5a.5.5 0 0 0 0 1h3.793l-1.147 1.146a.5.5 0 0 0 .708.708l2-2a.5.5 0 0 0 0-.708l-2-2a.5.5 0 0 0-.708.708L14.293 7.5H10.5a.5.5 0 0 0 0 1h3.793l-1.147-1.146a.5.5 0 1 0-.708.708l2 2z"/></svg>Pan</button>
                    <button id="add-vertex-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-node-plus" viewBox="0 0 16 16"><path d="M11 13a2 2 0 1 0 0-4 2 2 0 0 0 0 4"/><path fill-rule="evenodd" d="M11 5.5a.5.5 0 0 1 .5.5v1.525a3.001 3.001 0 0 1 2.5 2.958A3 3 0 0 1 11 14a3 3 0 0 1-2.5-1.517l-3.458-.993a2.501 2.501 0 0 1-1.882 1.502.5.5 0 1 1-.2-.98 1.5 1.5 0 0 0 1.122-1.152l-1.29-.371A.5.5 0 0 1 2 10V8a2 2 0 0 1 1.663-1.972A2.5 2.5 0 1 1 7.5 4.05V2.5a.5.5 0 0 1 1 0v1.55a2.5 2.5 0 0 1 1.468 1.305A.5.5 0 0 1 11 5.5ZM6 3.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0ZM3 8v1.5l1.46.42a2.5 2.5 0 0 1 2.467-.814l.844-1.403A1.5 1.5 0 0 0 6.5 6h-1a.5.5 0 0 1-.471-.332L4.5 4.61A1.999 1.999 0 0 1 3 6v2Zm5.937-.377.518-.862a1.5 1.5 0 0 0-.518-.76v1.622Zm.802.286A2.5 2.5 0 0 1 12 10.5V9a2 2 0 0 1-1.261-1.832Z"/><path d="M8.5 10a.5.5 0 0 1 .5-.5h2V7.5a.5.5 0 0 1 1 0V9.5h2a.5.5 0 0 1 0 1h-2V12.5a.5.5 0 0 1-1 0V10.5h-2a.5.5 0 0 1-.5-.5"/></svg>Add Vertex</button>
                    <button id="add-edge-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-diagram-2" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.5 1A1.5 1.5 0 0 1 16 2.5v3a1.5 1.5 0 0 1-1 1.415V9.5A1.5 1.5 0 0 1 13.5 11H9.415A1.5 1.5 0 0 1 8 11.915v1.585A1.5 1.5 0 0 1 6.5 15h-4A1.5 1.5 0 0 1 1 13.5v-4A1.5 1.5 0 0 1 2 8h1.585A1.5 1.5 0 0 1 4 6.585V2.5A1.5 1.5 0 0 1 5.5 1h9Zm-10 8h-2a.5.5 0 0 0-.5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 .5-.5H9v-1H6.5A1.5 1.5 0 0 0 5 11.5v2a1.5 1.5 0 0 1-.5.5ZM6 2.5v4A1.5 1.5 0 0 1 4.915 8h6.67A1.5 1.5 0 0 1 12.5 9.415V10h1a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5h-9a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5V3h-1V2.5a.5.5 0 0 0-.5-.5h-8Zm1.5 4a.5.5 0 0 0-.5.5V8h1.085A1.5 1.5 0 0 1 9 9.415V10h1v-.5A1.5 1.5 0 0 1 11.5 8h.5V7.5a.5.5 0 0 0-.5-.5h-4Z"/></svg>Add Edge</button>
                    <button id="delete-mode-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eraser" viewBox="0 0 16 16"><path d="M8.086 2.207a1.5 1.5 0 0 1 2.121 0l3.586 3.586a1.5 1.5 0 0 1 0 2.121l-5.5 5.5a1.5 1.5 0 0 1-1.06.439H3.914a1.5 1.5 0 0 1-1.06-.439l-1.5-1.5a1.5 1.5 0 0 1 0-2.122l6.732-6.732Zm-5.379 7.44a.5.5 0 0 0-.146.353.5.5 0 0 0 .146.354l1.5 1.5a.5.5 0 0 0 .353.146h3.318a.5.5 0 0 0 .353-.146l3.562-3.562-2.914-2.914-6.172 6.172Z"/></svg>Delete</button>
                </div>

                <div class="flex flex-wrap items-center gap-2">
                    <div class="relative">
                        <button id="align-vertices-btn" class="btn btn-secondary">Align Vertices ▾</button>
                        <div id="align-options-dropdown" class="origin-top-left absolute left-0 mt-2 w-56 rounded-lg shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-10" role="menu" aria-orientation="vertical" aria-labelledby="align-vertices-btn">
                            <div class="py-1" role="none"><a href="#" id="align-vertical-btn" class="text-gray-700 block px-4 py-2 text-sm hover:bg-gray-100" role="menuitem">Align Vertically</a><a href="#" id="align-horizontal-btn" class="text-gray-700 block px-4 py-2 text-sm hover:bg-gray-100" role="menuitem">Align Horizontally</a></div>
                        </div>
                    </div>
                    <div class="flex items-center gap-2 bg-white border border-slate-200 px-2 py-1 rounded-lg">
                        <label for="auto-label-type" class="text-xs font-semibold text-slate-500">Auto labels</label>
                        <select id="auto-label-type" class="form-select text-sm w-32">
                            <option value="numeric">1, 2, 3…</option><option value="alpha">a, b, c…</option><option value="none">None</option>
                        </select>
                    </div>
                    <button id="undo-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.408a.25.25 0 0 0 0 .384l2.36 2.066A.25.25 0 0 0 8 4.466z"/></svg>Undo</button>
                    <button id="redo-btn" class="btn btn-secondary"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 2.066a.25.25 0 0 1 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>Redo</button>
                </div>

                <div class="flex flex-wrap items-center gap-2 ml-auto">
                    <button id="download-svg-btn" class="btn btn-secondary">Download SVG</button>
                    <button id="download-png-btn" class="btn btn-secondary">Download PNG</button>
                    <button id="download-selected-svg-btn" class="btn btn-secondary" disabled>Selected SVG</button>
                    <button id="download-selected-png-btn" class="btn btn-secondary" disabled>Selected PNG</button>
                </div>
            </div>

            <div class="flex flex-grow min-h-[26rem]">
                <div class="flex-grow relative bg-white" id="canvas-wrapper">
                    <svg id="canvas" class="w-full h-full rounded-b-xl"></svg>
                    <div class="absolute bottom-4 right-4 flex flex-col gap-2">
                        <button id="zoom-in-btn" class="btn btn-secondary !p-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-zoom-in" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/><path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/><path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/></svg></button>
                        <button id="zoom-out-btn" class="btn btn-secondary !p-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-zoom-out" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/><path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/><path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/></svg></button>
                    </div>
                </div>
                <aside id="properties-panel" class="w-80 bg-slate-50 border-l border-slate-200 p-4 overflow-y-auto transition-all duration-300 hidden">
                    <div id="vertex-props" class="hidden space-y-4 relative">
                         <button id="close-vertex-props-btn" class="absolute top-0 right-0 text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                        <h3 class="text-lg font-semibold text-gray-800 border-b border-gray-200 pb-2">Vertex Properties</h3>
                        <div class="form-group"><label for="vertex-label">Label</label><input type="text" id="vertex-label" class="form-input"></div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="form-group"><label for="vertex-size">Size</label><select id="vertex-size" class="form-select"><option value="6">Small</option><option value="10" selected>Medium</option><option value="14">Large</option></select></div>
                            <div class="form-group"><label for="vertex-fill-type">Fill</label><select id="vertex-fill-type" class="form-select"><option value="solid">Solid</option><option value="empty">Empty</option></select></div>
                        </div>
                        <div class="form-group" id="vertex-color-group"><label for="vertex-color">Fill Color</label><input type="color" id="vertex-color" value="#628dc6" class="w-full h-10 p-1 border border-gray-300 bg-white rounded-lg"></div>
                        <div class="form-group"><label for="vertex-border">Border</label><select id="vertex-border" class="form-select"><option value="1">Thin</option><option value="1.5" selected>Normal</option><option value="2.5">Thick</option></select></div>
                        <button id="apply-to-all-vertices-btn" class="btn btn-primary w-full">Apply Styles to All Vertices</button>
                    </div>
                    <div id="edge-props" class="hidden space-y-4 relative">
                        <button id="close-edge-props-btn" class="absolute top-0 right-0 text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                        <h3 class="text-lg font-semibold text-gray-800 border-b border-gray-200 pb-2">Edge Properties</h3>
                        <div class="form-group"><label for="edge-type">Type</label><select id="edge-type" class="form-select"><option value="undirected">Undirected</option><option value="directed">Directed</option></select></div>
                        <div class="form-group"><label for="edge-style">Style</label><select id="edge-style" class="form-select"><option value="solid">Solid</option><option value="dashed">Dashed</option><option value="dotted">Dotted</option></select></div>
                        <div class="form-group flex items-center justify-center"><button id="reset-bend-btn" class="btn btn-secondary">Reset Bend</button></div>
                        <button id="apply-to-all-edges-btn" class="btn btn-primary w-full">Apply Styles to All Edges</button>
                    </div>
                    <div id="no-selection" class="text-center text-gray-500 mt-8"><p>Click an element on the canvas to see its properties.</p><p id="multi-select-info" class="hidden text-sm mt-2">Multiple items selected.</p></div>
                </aside>
            </div>
        </div>

        <div class="panel-card bg-white border border-slate-200">
            <div class="p-3 flex justify-between items-center border-b border-gray-200 bg-white/60"><h3 class="text-md font-semibold text-gray-800 px-2">Generated TikZ Code</h3><button id="copy-button" class="btn btn-primary">Copy Code</button></div>
            <textarea id="tikz-code" readonly class="flex-grow w-full p-4 box-border border-none font-mono text-sm resize-none bg-white text-gray-800 focus:outline-none" style="min-height: 8rem;"></textarea>
            <div class="bg-white border-t border-gray-200 p-3 flex items-center gap-4 text-sm flex-wrap">
                <div class="flex items-center gap-2"><input type="checkbox" id="center-drawing-check" class="form-checkbox"><label for="center-drawing-check">Center Drawing</label></div>
                <div class="flex items-center gap-2"><input type="checkbox" id="add-caption-check" class="form-checkbox"><label for="add-caption-check" id="add-caption-label">Add Caption</label></div>
                <input type="text" id="caption-input" placeholder="Enter caption text..." class="form-input text-sm py-1 flex-1 min-w-[10rem]" disabled>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const svg = document.getElementById('canvas');
            const propertiesPanel = document.getElementById('properties-panel');
            const noSelectionPanel = document.getElementById('no-selection');
            const multiSelectInfo = document.getElementById('multi-select-info');
            const vertexPropsPanel = document.getElementById('vertex-props');
            const edgePropsPanel = document.getElementById('edge-props');
            const tikzCodeArea = document.getElementById('tikz-code');
            const NS = 'http://www.w3.org/2000/svg';

            let state = { vertices: [], edges: [], nextVertexId: 0, nextEdgeId: 0, selectedElements: [], mode: 'select', edgeStartVertex: null, autoLabelType: 'numeric', draggedElement: null, pan: {x: 0, y: 0}, zoom: 1 };
            let isMarqueeSelecting = false, marqueeRect = null, marqueeStartPoint = { x: 0, y: 0 }, clipboard = { vertices: [], edges: [] }, lastMouseCoords = { x: 0, y: 0 };
            let isPanning = false, panStartPoint = {x: 0, y: 0};
            let history = [], historyPointer = -1;
            const TIKZ_SCALE_FACTOR = 40;

            const selectModeBtn = document.getElementById('select-mode-btn');
            const panModeBtn = document.getElementById('pan-mode-btn');
            const addVertexBtn = document.getElementById('add-vertex-btn');
            const addEdgeBtn = document.getElementById('add-edge-btn');
            const deleteModeBtn = document.getElementById('delete-mode-btn');
            const alignVerticesBtn = document.getElementById('align-vertices-btn');
            const alignOptionsDropdown = document.getElementById('align-options-dropdown');
            const alignVerticalBtn = document.getElementById('align-vertical-btn');
            const alignHorizontalBtn = document.getElementById('align-horizontal-btn');
            const autoLabelTypeSelect = document.getElementById('auto-label-type');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const showInstructionsBtn = document.getElementById('show-instructions-btn');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsBtn = document.getElementById('close-instructions-btn');
            const copyBtn = document.getElementById('copy-button');
            const resetBendBtn = document.getElementById('reset-bend-btn');
            const centerCheck = document.getElementById('center-drawing-check');
            const captionCheck = document.getElementById('add-caption-check');
            const captionInput = document.getElementById('caption-input');
            const applyToAllVerticesBtn = document.getElementById('apply-to-all-vertices-btn');
            const applyToAllEdgesBtn = document.getElementById('apply-to-all-edges-btn');
            const downloadSvgBtn = document.getElementById('download-svg-btn');
            const downloadPngBtn = document.getElementById('download-png-btn');
            const downloadSelectedSvgBtn = document.getElementById('download-selected-svg-btn');
            const downloadSelectedPngBtn = document.getElementById('download-selected-png-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const closeVertexPropsBtn = document.getElementById('close-vertex-props-btn');
            const closeEdgePropsBtn = document.getElementById('close-edge-props-btn');
            const activeModeLabel = document.getElementById('active-mode-label');
            
            const modeButtons = { 'select': selectModeBtn, 'pan': panModeBtn, 'addVertex': addVertexBtn, 'addEdge': addEdgeBtn, 'delete': deleteModeBtn };

            const vertexLabelInput = document.getElementById('vertex-label');
            const vertexSizeSelect = document.getElementById('vertex-size');
            const vertexFillTypeSelect = document.getElementById('vertex-fill-type');
            const vertexColorInput = document.getElementById('vertex-color');
            const vertexColorGroup = document.getElementById('vertex-color-group');
            const vertexBorderSelect = document.getElementById('vertex-border');
            const edgeTypeSelect = document.getElementById('edge-type');
            const edgeStyleSelect = document.getElementById('edge-style');

            function saveState() { history = history.slice(0, historyPointer + 1); history.push(JSON.parse(JSON.stringify(state))); historyPointer++; updateToolbarButtons(); }
            function undo() { if (historyPointer > 0) { historyPointer--; loadState(history[historyPointer]); } }
            function redo() { if (historyPointer < history.length - 1) { historyPointer++; loadState(history[historyPointer]); } }
            function loadState(newState) { state = JSON.parse(JSON.stringify(newState)); autoLabelTypeSelect.value = state.autoLabelType; setMode(state.mode, true); render(); updateToolbarButtons(); }
            function updateToolbarButtons() {
                undoBtn.disabled = historyPointer <= 0;
                redoBtn.disabled = historyPointer >= history.length - 1;
                const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex');
                alignVerticesBtn.disabled = selectedVertices.length < 2;
                const hasVerticesSelected = selectedVertices.length > 0;
                downloadSelectedSvgBtn.disabled = !hasVerticesSelected;
                downloadSelectedPngBtn.disabled = !hasVerticesSelected;
            }
            function getSVGCoords(evt) { const rect = svg.getBoundingClientRect(); const x = (evt.clientX - rect.left) / state.zoom + state.pan.x; const y = (evt.clientY - rect.top) / state.zoom + state.pan.y; return { x, y }; }
            function addVertex(x, y) { const newVertex = { id: state.nextVertexId++, x, y, label: '', radius: 10, fillType: 'solid', fillColor: '#628dc6', borderWidth: 1.5, borderColor: '#6b7280', type: 'vertex' }; const n = state.vertices.length; if (state.autoLabelType === 'numeric') newVertex.label = (n + 1).toString(); else if (state.autoLabelType === 'alpha') newVertex.label = String.fromCharCode(97 + n); state.vertices.push(newVertex); saveState(); selectElement(newVertex); render(); }
            function addEdge(sourceId, targetId) { if (sourceId === targetId || state.edges.some(e => (e.sourceId === sourceId && e.targetId === targetId) || (e.sourceId === targetId && e.targetId === sourceId))) return; const newEdge = { id: state.nextEdgeId++, sourceId, targetId, type: 'edge', edgeType: 'undirected', lineStyle: 'solid', controlPoint: { x: 0, y: 0, isDefault: true } }; state.edges.push(newEdge); saveState(); }
            function deleteSelectedElements() { if (state.selectedElements.length === 0) return; const idsToDelete = new Set(state.selectedElements.map(el => el.id)); const typesToDelete = new Set(state.selectedElements.map(el => el.type)); if (typesToDelete.has('vertex')) { state.vertices = state.vertices.filter(v => !idsToDelete.has(v.id)); state.edges = state.edges.filter(e => !idsToDelete.has(e.sourceId) && !idsToDelete.has(e.targetId)); } if (typesToDelete.has('edge')) { state.edges = state.edges.filter(e => !idsToDelete.has(e.id)); } selectElement(null); saveState(); render(); }
            function alignSelectedVertices(alignmentType) { const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex'); if (selectedVertices.length < 2) return; let avgX = 0, avgY = 0; selectedVertices.forEach(v => { avgX += v.x; avgY += v.y; }); avgX /= selectedVertices.length; avgY /= selectedVertices.length; const selectedIds = new Set(selectedVertices.map(v => v.id)); state.vertices.forEach(v => { if (selectedIds.has(v.id)) { if (alignmentType === 'horizontal') v.y = avgY; if (alignmentType === 'vertical') v.x = avgX; } }); state.edges.forEach(edge => { if (edge.controlPoint.isDefault) { const source = state.vertices.find(v => v.id === edge.sourceId), target = state.vertices.find(v => v.id === edge.targetId); if (source && target) { edge.controlPoint.x = (source.x + target.x) / 2; edge.controlPoint.y = (source.y + target.y) / 2; } } }); saveState(); render(); }
            function copySelection() { if (state.selectedElements.length === 0) return; const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex'); const selectedEdges = state.selectedElements.filter(el => el.type === 'edge'); clipboard.vertices = JSON.parse(JSON.stringify(selectedVertices)); clipboard.edges = JSON.parse(JSON.stringify(selectedEdges)); }
            function pasteFromClipboard() { if (clipboard.vertices.length === 0 && clipboard.edges.length === 0) return; const oldToNewIdMap = new Map(), newSelection = []; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; if (clipboard.vertices.length > 0) { clipboard.vertices.forEach(v => { minX = Math.min(minX, v.x); minY = Math.min(minY, v.y); maxX = Math.max(maxX, v.x); maxY = Math.max(maxY, v.y); }); } else { minX = lastMouseCoords.x; maxX = lastMouseCoords.x; minY = lastMouseCoords.y; maxY = lastMouseCoords.y; } const selectionCenterX = (minX + maxX) / 2, selectionCenterY = (minY + maxY) / 2; const offsetX = lastMouseCoords.x - selectionCenterX, offsetY = lastMouseCoords.y - selectionCenterY; clipboard.vertices.forEach(v => { const oldId = v.id; const newVertex = JSON.parse(JSON.stringify(v)); newVertex.id = state.nextVertexId++; newVertex.x += offsetX; newVertex.y += offsetY; state.vertices.push(newVertex); oldToNewIdMap.set(oldId, newVertex.id); newSelection.push(newVertex); }); clipboard.edges.forEach(e => { const newEdge = JSON.parse(JSON.stringify(e)); newEdge.id = state.nextEdgeId++; newEdge.sourceId = oldToNewIdMap.get(e.sourceId); newEdge.targetId = oldToNewIdMap.get(e.targetId); if (newEdge.sourceId !== undefined && newEdge.targetId !== undefined) { if (!e.controlPoint.isDefault) { newEdge.controlPoint.x += offsetX; newEdge.controlPoint.y += offsetY; } state.edges.push(newEdge); newSelection.push(newEdge); } }); state.selectedElements = newSelection; updatePropertiesPanel(); saveState(); render(); }
            function setMode(newMode, fromLoad = false) {
                if (!fromLoad && state.mode === newMode) newMode = 'select';
                state.mode = newMode;
                Object.values(modeButtons).forEach(btn => btn.classList.remove('active'));
                if (modeButtons[state.mode]) modeButtons[state.mode].classList.add('active');
                svg.style.cursor = { 'pan': 'grab', 'addVertex': 'crosshair', 'addEdge': 'pointer', 'delete': 'pointer' }[state.mode] || 'default';
                if (activeModeLabel) activeModeLabel.textContent = state.mode.charAt(0).toUpperCase() + state.mode.slice(1);
                state.edgeStartVertex = null;
                render();
            }
            function selectElement(element, isMultiSelect = false) { if (isMultiSelect) { const index = state.selectedElements.findIndex(el => el.id === element.id && el.type === element.type); if (index > -1) state.selectedElements.splice(index, 1); else state.selectedElements.push(element); } else { state.selectedElements = element ? [element] : []; } updatePropertiesPanel(); updateToolbarButtons(); }
            function updatePropertiesPanel() { const selectedCount = state.selectedElements.length; propertiesPanel.classList.toggle('hidden', selectedCount === 0); noSelectionPanel.classList.toggle('hidden', selectedCount > 0); multiSelectInfo.classList.toggle('hidden', selectedCount <= 1); vertexPropsPanel.classList.add('hidden'); edgePropsPanel.classList.add('hidden'); if (selectedCount === 1) { const selected = state.selectedElements[0]; if (selected.type === 'vertex') { vertexPropsPanel.classList.remove('hidden'); const v = selected; vertexLabelInput.value = v.label; vertexSizeSelect.value = v.radius; vertexFillTypeSelect.value = v.fillType; vertexColorInput.value = v.fillColor; vertexBorderSelect.value = v.borderWidth; vertexColorGroup.style.display = v.fillType === 'solid' ? 'block' : 'none'; } else if (selected.type === 'edge') { edgePropsPanel.classList.remove('hidden'); const e = selected; edgeTypeSelect.value = e.edgeType; edgeStyleSelect.value = e.lineStyle; } } }
            
            function render() {
                const { width, height } = svg.getBoundingClientRect();
                svg.setAttribute('viewBox', `${state.pan.x} ${state.pan.y} ${width / state.zoom} ${height / state.zoom}`);
                svg.innerHTML = ''; // Clear previous render
                const defs = document.createElementNS(NS, 'defs');

                const markerDefault = document.createElementNS(NS, 'marker');
                markerDefault.setAttribute('id', 'arrowhead-default');
                markerDefault.setAttribute('viewBox', '0 -1.5 2.5 3'); 
                markerDefault.setAttribute('refX', '2'); 
                markerDefault.setAttribute('refY', '0');
                markerDefault.setAttribute('markerWidth', '2'); 
                markerDefault.setAttribute('markerHeight', '2');
                markerDefault.setAttribute('orient', 'auto');
                const pathDefault = document.createElementNS(NS, 'path');
                pathDefault.setAttribute('d', 'M0,-1L2,0L0,1');
                pathDefault.setAttribute('fill', 'currentColor');
                markerDefault.appendChild(pathDefault);
                defs.appendChild(markerDefault);

                const markerSelected = document.createElementNS(NS, 'marker');
                markerSelected.setAttribute('id', 'arrowhead-selected');
                markerSelected.setAttribute('viewBox', '-2 -5 10 10');
                markerSelected.setAttribute('refX', '8');
                markerSelected.setAttribute('refY', '0');
                markerSelected.setAttribute('markerWidth', '6');
                markerSelected.setAttribute('markerHeight', '6');
                markerSelected.setAttribute('orient', 'auto');
                const pathSelected = document.createElementNS(NS, 'path');
                pathSelected.setAttribute('d', 'M0,-4L8,0L0,4');
                pathSelected.setAttribute('fill', 'currentColor');
                markerSelected.appendChild(pathSelected);
                defs.appendChild(markerSelected);

                svg.appendChild(defs);

                const isSelected = (el) => state.selectedElements.some(sel => sel.id === el.id && sel.type === el.type);
                
                state.edges.forEach(edge => {
                    const source = state.vertices.find(v => v.id === edge.sourceId);
                    const target = state.vertices.find(v => v.id === edge.targetId);
                    if (!source || !target) return;
                    
                    const g = document.createElementNS(NS, 'g');
                    g.classList.add('edge');
                    if (isSelected(edge)) g.classList.add('selected');
                    
                    if (edge.controlPoint.isDefault) {
                        edge.controlPoint.x = (source.x + target.x) / 2;
                        edge.controlPoint.y = (source.y + target.y) / 2;
                    }
                    
                    const pathEl = document.createElementNS(NS, 'path');
                    pathEl.classList.add('edge-path');

                    const getBorderPoint = (from, to, vertex) => {
                        let dx = to.x - from.x;
                        let dy = to.y - from.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len === 0) return to;
                        const offset = parseFloat(vertex.radius) + (parseFloat(vertex.borderWidth) / 2);
                        return {
                            x: to.x - (dx / len) * offset,
                            y: to.y - (dy / len) * offset
                        };
                    };

                    const controlPoint = edge.controlPoint.isDefault ? { x: (source.x + target.x) / 2, y: (source.y + target.y) / 2 } : edge.controlPoint;
                    
                    const finalSource = getBorderPoint(controlPoint, source, source);
                    const finalTarget = getBorderPoint(controlPoint, target, target);

                    pathEl.setAttribute('d', `M ${finalSource.x} ${finalSource.y} Q ${controlPoint.x} ${controlPoint.y} ${finalTarget.x} ${finalTarget.y}`);
                    
                    if (edge.lineStyle === 'dashed') pathEl.style.strokeDasharray = '5,5';
                    if (edge.lineStyle === 'dotted') pathEl.style.strokeDasharray = '1.5,4';
                    
                    if (edge.edgeType === 'directed') {
                        pathEl.setAttribute('marker-end', isSelected(edge) ? 'url(#arrowhead-selected)' : 'url(#arrowhead-default)');
                    }
                    
                    const interactionArea = pathEl.cloneNode();
                    interactionArea.classList.add('edge-interaction-area');
                    g.appendChild(pathEl);
                    g.appendChild(interactionArea);
                    
                    interactionArea.addEventListener('mousedown', (e) => { e.stopPropagation(); if (state.mode === 'delete') deleteSelectedElements(); else { selectElement(edge, e.shiftKey); render(); } });
                    interactionArea.addEventListener('mouseenter', () => { g.classList.add('hovered'); if (state.mode === 'delete') g.classList.add('delete-mode-hover'); });
                    interactionArea.addEventListener('mouseleave', () => g.classList.remove('hovered', 'delete-mode-hover'));
                    
                    const handle = document.createElementNS(NS, 'circle');
                    handle.classList.add('edge-handle');
                    handle.setAttribute('cx', edge.controlPoint.x);
                    handle.setAttribute('cy', edge.controlPoint.y);
                    handle.setAttribute('r', '6');
                    handle.addEventListener('mousedown', (e) => { e.stopPropagation(); state.draggedElement = { type: 'handle', edgeId: edge.id }; });
                    
                    g.appendChild(handle);
                    svg.appendChild(g);
                });

                state.vertices.forEach(vertex => {
                    const g = document.createElementNS(NS, 'g');
                    g.classList.add('vertex');
                    g.setAttribute('transform', `translate(${vertex.x}, ${vertex.y})`);
                    if (isSelected(vertex)) g.classList.add('selected');
                    if (state.edgeStartVertex && state.edgeStartVertex.id === vertex.id) g.classList.add('edge-start');
                    
                    const circle = document.createElementNS(NS, 'circle');
                    circle.classList.add('vertex-shape');
                    circle.setAttribute('r', vertex.radius);
                    circle.style.fill = vertex.fillType === 'solid' ? vertex.fillColor : 'transparent';
                    circle.style.stroke = vertex.borderColor;
                    circle.style.strokeWidth = vertex.borderWidth;
                    
                    const label = document.createElementNS(NS, 'text');
                    label.classList.add('vertex-label');
                    label.textContent = vertex.label;
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('dy', '.3em');
                    
                    g.appendChild(circle);
                    g.appendChild(label);
                    
                    g.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        if (state.mode === 'addEdge') {
                            if (!state.edgeStartVertex) { state.edgeStartVertex = vertex; render(); } 
                            else { addEdge(state.edgeStartVertex.id, vertex.id); state.edgeStartVertex = null; render(); }
                        } else if (state.mode === 'delete') {
                            selectElement(vertex, e.shiftKey);
                            deleteSelectedElements();
                        } else {
                            state.draggedElement = { type: 'vertex', id: vertex.id, startX: e.clientX, startY: e.clientY };
                            if (!isSelected(vertex)) { selectElement(vertex, e.shiftKey); }
                            render();
                        }
                    });
                    g.addEventListener('mouseenter', () => { g.classList.add('hovered'); if (state.mode === 'delete') g.classList.add('delete-mode-hover'); });
                    g.addEventListener('mouseleave', () => g.classList.remove('hovered', 'delete-mode-hover'));
                    svg.appendChild(g);
                });

                if (marqueeRect) { svg.appendChild(marqueeRect); }
                generateTikZ();
            }

            function generateTikZ() { const doCenter = centerCheck.checked, doCaption = captionCheck.checked, captionText = captionInput.value; const hexToName = {}; let colorIndex = 0; state.vertices.forEach(v => { if (!hexToName[v.borderColor]) hexToName[v.borderColor] = `mycolor${colorIndex++}`; if (v.fillType === 'solid' && !hexToName[v.fillColor]) hexToName[v.fillColor] = `mycolor${colorIndex++}`; }); let code = ''; for (const hex in hexToName) code += `\\definecolor{${hexToName[hex]}}{HTML}{${hex.substring(1)}}\n`; if (doCenter || doCaption) code += `\\begin{figure}[h!]\n${doCenter ? '  \\centering\n' : ''}`; code += '  \\begin{tikzpicture}[every node/.style={draw, circle}]\n'; const canvasHeight = svg.getBoundingClientRect().height; const tikzBorder = { 1: 'thin', 1.5: '', 2.5: 'thick' }; const sizeMap = { 6: '0.4cm', 10: '0.6cm', 14: '0.8cm' }; code += '    % Vertices\n'; state.vertices.forEach(v => { const x = (v.x / TIKZ_SCALE_FACTOR).toFixed(2), y = ((canvasHeight - v.y) / TIKZ_SCALE_FACTOR).toFixed(2); let styles = [`draw=${hexToName[v.borderColor]}`]; if (v.fillType === 'solid') styles.push(`fill=${hexToName[v.fillColor]}`); else styles.push('fill=none'); styles.push(`minimum size=${sizeMap[v.radius]}`); if (tikzBorder[v.borderWidth]) styles.push(tikzBorder[v.borderWidth]); code += `    \\node[${styles.join(', ')}] (v${v.id}) at (${x}, ${y}) {${v.label}};\n`; }); code += '\n    % Edges\n'; state.edges.forEach(e => { let styles = []; if (e.edgeType === 'directed') styles.push('-{stealth}'); if (e.lineStyle === 'dashed') styles.push('dashed'); if (e.lineStyle === 'dotted') styles.push('dotted'); const styleString = styles.length > 0 ? `[${styles.join(', ')}]` : ''; const source = state.vertices.find(v => v.id === e.sourceId), target = state.vertices.find(v => v.id === e.targetId); if (!source || !target) return; const isBent = Math.sqrt((e.controlPoint.x - (source.x + target.x)/2)**2 + (e.controlPoint.y - (source.y + target.y)/2)**2) > 2; if (isBent) { const cx = (e.controlPoint.x / TIKZ_SCALE_FACTOR).toFixed(2), cy = ((canvasHeight - e.controlPoint.y) / TIKZ_SCALE_FACTOR).toFixed(2); code += `    \\draw${styleString} (v${e.sourceId}) .. controls (${cx},${cy}) .. (v${e.targetId});\n`; } else code += `    \\draw${styleString} (v${e.sourceId}) -- (v${e.targetId});\n`; }); code += '  \\end{tikzpicture}'; if (doCenter || doCaption) { if (doCaption && captionText) code += `\n  \\caption{${captionText}}\n`; code += '\\end{figure}'; } tikzCodeArea.value = code; }

            function getBoundingBox(elements) {
                const vertices = elements.filter(el => el.type === 'vertex');
                if (vertices.length === 0) return null;

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                vertices.forEach(v => {
                    const radius = parseFloat(v.radius);
                    minX = Math.min(minX, v.x - radius);
                    minY = Math.min(minY, v.y - radius);
                    maxX = Math.max(maxX, v.x + radius);
                    maxY = Math.max(maxY, v.y + radius);
                });
                return { minX, minY, maxX, maxY };
            }

            // --- START: FIXED DOWNLOAD FUNCTIONS ---

            function getSVGForExport(elements) {
                const verticesToExport = elements.filter(el => el.type === 'vertex');
                const edgesToExport = elements.filter(el => el.type === 'edge');
                const vertexIdsToExport = new Set(verticesToExport.map(v => v.id));

                // This filter is now redundant if the calling function pre-filters, but it's safe to keep.
                const validEdges = edgesToExport.filter(edge =>
                    vertexIdsToExport.has(edge.sourceId) && vertexIdsToExport.has(edge.targetId)
                );

                let svgString = `<svg xmlns="${NS}">`;

                // 1. Add Defs (arrowheads)
                if (svg.querySelector('defs')) {
                    svgString += svg.querySelector('defs').outerHTML;
                }

                // 2. Add Styles (for vertices)
                const cssStyles = `
                    .vertex-label { font-family: 'Inter', sans-serif; font-size: 12px; fill: #1d2129; user-select: none; }
                `;
                svgString += `<style>${cssStyles}</style>`;

                // 3. Add Edges with inline styles
                validEdges.forEach(edge => {
                    const source = state.vertices.find(v => v.id === edge.sourceId);
                    const target = state.vertices.find(v => v.id === edge.targetId);
                    if (!source || !target) return;

                    const controlPoint = edge.controlPoint.isDefault ? { x: (source.x + target.x) / 2, y: (source.y + target.y) / 2 } : edge.controlPoint;
                    
                    const getBorderPoint = (from, to, vertex) => {
                        let dx = to.x - from.x; let dy = to.y - from.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len === 0) return to;
                        const offset = parseFloat(vertex.radius) + (parseFloat(vertex.borderWidth) / 2);
                        return { x: to.x - (dx / len) * offset, y: to.y - (dy / len) * offset };
                    };

                    const finalSource = getBorderPoint(controlPoint, source, source);
                    const finalTarget = getBorderPoint(controlPoint, target, target);
                    const pathD = `M ${finalSource.x} ${finalSource.y} Q ${controlPoint.x} ${controlPoint.y} ${finalTarget.x} ${finalTarget.y}`;
                    
                    let styles = [
                        'fill: none',
                        'stroke: #6b7280', // Default color
                        'stroke-width: 1.5px' // Default width
                    ];

                    if (edge.lineStyle === 'dashed') styles.push('stroke-dasharray: 5,5');
                    if (edge.lineStyle === 'dotted') styles.push('stroke-dasharray: 1.5,4');
                    
                    const styleString = `style="${styles.join(';')}"`;

                    let marker = '';
                    if (edge.edgeType === 'directed') marker = `marker-end="url(#arrowhead-default)" color="#6b7280"`;

                    svgString += `<path d="${pathD}" ${styleString} ${marker} />`;
                });

                // 4. Add Vertices
                verticesToExport.forEach(vertex => {
                    svgString += `<g class="vertex" transform="translate(${vertex.x}, ${vertex.y})">`;
                    const fill = vertex.fillType === 'solid' ? vertex.fillColor : 'transparent';
                    svgString += `<circle class="vertex-shape" r="${vertex.radius}" style="fill: ${fill}; stroke: ${vertex.borderColor}; stroke-width: ${vertex.borderWidth};" />`;
                    svgString += `<text class="vertex-label" text-anchor="middle" dy=".3em">${vertex.label}</text>`;
                    svgString += `</g>`;
                });

                svgString += `</svg>`;
                return svgString;
            }

            function downloadImage(isPng, selectedOnly) {
                let elementsToExport;
                let verticesToConsider;

                if (selectedOnly) {
                    const selectedVertices = state.selectedElements.filter(el => el.type === 'vertex');
                    const selectedVertexIds = new Set(selectedVertices.map(v => v.id));
                    
                    // Find all edges in the main state that connect two of the selected vertices
                    const connectingEdges = state.edges.filter(edge => 
                        selectedVertexIds.has(edge.sourceId) && selectedVertexIds.has(edge.targetId)
                    );

                    elementsToExport = [...selectedVertices, ...connectingEdges];
                    verticesToConsider = selectedVertices;
                } else {
                    elementsToExport = [...state.vertices, ...state.edges];
                    verticesToConsider = state.vertices;
                }

                if (selectedOnly && verticesToConsider.length === 0) {
                    console.warn("Cannot export an empty or edge-only selection.");
                    return;
                }

                const bbox = verticesToConsider.length > 0 ? getBoundingBox(verticesToConsider) : { minX: 0, minY: 0, maxX: 100, maxY: 100 };
                const padding = 20;
                const contentWidth = (bbox.maxX - bbox.minX) + padding * 2;
                const contentHeight = (bbox.maxY - bbox.minY) + padding * 2;
                
                const rawSvgData = getSVGForExport(elementsToExport);
                const finalSVGData = rawSvgData.replace(
                    /<svg[^>]+>/, 
                    `<svg width="${contentWidth}" height="${contentHeight}" viewBox="${bbox.minX - padding} ${bbox.minY - padding} ${contentWidth} ${contentHeight}" xmlns="http://www.w3.org/2000/svg">`
                );
                
                const blob = new Blob([finalSVGData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                if (isPng) {
                    const canvasEl = document.createElement('canvas');
                    const scale = 2; // For higher resolution PNG
                    canvasEl.width = contentWidth * scale;
                    canvasEl.height = contentHeight * scale;
                    const ctx = canvasEl.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);

                    const img = new Image();
                    img.onload = function () {
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(url);
                        const a = document.createElement('a');
                        a.href = canvasEl.toDataURL('image/png');
                        a.download = selectedOnly ? 'graph-selection.png' : 'graph.png';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    };
                    img.onerror = function() {
                        console.error("Error loading SVG image for PNG conversion.");
                        URL.revokeObjectURL(url);
                    }
                    img.src = url;
                } else {
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = selectedOnly ? 'graph-selection.svg' : 'graph.svg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            // --- END: FIXED DOWNLOAD FUNCTIONS ---

            function zoomCanvas(direction, mouseX, mouseY) {
                const { width, height } = svg.getBoundingClientRect();
                const zoomFactor = direction === 'in' ? 1.2 : 1 / 1.2;
                const newZoom = Math.max(0.1, Math.min(10, state.zoom * zoomFactor));

                const screenX = mouseX - svg.getBoundingClientRect().left;
                const screenY = mouseY - svg.getBoundingClientRect().top;
                
                const worldXBefore = (screenX / state.zoom) + state.pan.x;
                const worldYBefore = (screenY / state.zoom) + state.pan.y;

                const worldXAfter = (screenX / newZoom) + state.pan.x;
                const worldYAfter = (screenY / newZoom) + state.pan.y;

                state.pan.x += worldXBefore - worldXAfter;
                state.pan.y += worldYBefore - worldYAfter;
                state.zoom = newZoom;
                
                render();
            }

            // Event Listeners
            selectModeBtn.addEventListener('click', () => setMode('select'));
            panModeBtn.addEventListener('click', () => setMode('pan'));
            addVertexBtn.addEventListener('click', () => setMode('addVertex'));
            addEdgeBtn.addEventListener('click', () => setMode('addEdge'));
            deleteModeBtn.addEventListener('click', () => setMode('delete'));
            alignVerticesBtn.addEventListener('click', (e) => {
                if (alignVerticesBtn.disabled) return;
                e.stopPropagation();
                alignOptionsDropdown.classList.toggle('hidden');
            });
            alignVerticalBtn.addEventListener('click', (e) => { e.preventDefault(); alignSelectedVertices('vertical'); alignOptionsDropdown.classList.add('hidden'); });
            alignHorizontalBtn.addEventListener('click', (e) => { e.preventDefault(); alignSelectedVertices('horizontal'); alignOptionsDropdown.classList.add('hidden'); });
            window.addEventListener('click', () => { if (!alignOptionsDropdown.classList.contains('hidden')) { alignOptionsDropdown.classList.add('hidden'); } });
            autoLabelTypeSelect.addEventListener('change', (e) => {
                state.autoLabelType = e.target.value;
                state.vertices.forEach((vertex, i) => {
                    if (state.autoLabelType === 'numeric') {
                        vertex.label = (i + 1).toString();
                    } else if (state.autoLabelType === 'alpha') {
                        vertex.label = String.fromCharCode(97 + i);
                    } else {
                        vertex.label = '';
                    }
                });
                saveState();
                render();
            });
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            showInstructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
            closeInstructionsBtn.addEventListener('click', () => instructionsModal.classList.add('hidden'));
            instructionsModal.addEventListener('click', (e) => { if (e.target === instructionsModal) instructionsModal.classList.add('hidden'); });
            copyBtn.addEventListener('click', () => { tikzCodeArea.select(); document.execCommand('copy'); copyBtn.textContent = 'Copied!'; setTimeout(() => { copyBtn.textContent = 'Copy Code'; }, 2000); });
            resetBendBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'edge') { state.selectedElements[0].controlPoint.isDefault = true; saveState(); render(); } });
            applyToAllVerticesBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'vertex') { const style = state.selectedElements[0]; state.vertices.forEach(v => { v.radius = style.radius; v.fillType = style.fillType; v.fillColor = style.fillColor; v.borderWidth = style.borderWidth; v.borderColor = style.borderColor; }); saveState(); render(); } });
            applyToAllEdgesBtn.addEventListener('click', () => { if (state.selectedElements.length === 1 && state.selectedElements[0].type === 'edge') { const style = state.selectedElements[0]; state.edges.forEach(e => { e.edgeType = style.edgeType; e.lineStyle = style.lineStyle; }); saveState(); render(); } });
            centerCheck.addEventListener('change', generateTikZ);
            captionCheck.addEventListener('change', () => { captionInput.disabled = !captionCheck.checked; generateTikZ(); });
            captionInput.addEventListener('input', generateTikZ);
            
            downloadSvgBtn.addEventListener('click', () => downloadImage(false, false));
            downloadPngBtn.addEventListener('click', () => downloadImage(true, false));
            downloadSelectedSvgBtn.addEventListener('click', () => downloadImage(false, true));
            downloadSelectedPngBtn.addEventListener('click', () => downloadImage(true, true));
            
            zoomInBtn.addEventListener('click', () => { const { width, height } = svg.getBoundingClientRect(); zoomCanvas('in', width / 2, height / 2); });
            zoomOutBtn.addEventListener('click', () => { const { width, height } = svg.getBoundingClientRect(); zoomCanvas('out', width / 2, height / 2); });
            closeVertexPropsBtn.addEventListener('click', () => { selectElement(null); propertiesPanel.classList.add('hidden'); });
            closeEdgePropsBtn.addEventListener('click', () => { selectElement(null); propertiesPanel.classList.add('hidden'); });

            svg.addEventListener('wheel', (e) => { e.preventDefault(); zoomCanvas(e.deltaY < 0 ? 'in' : 'out', e.clientX, e.clientY); });

            svg.addEventListener('mousedown', (e) => {
                if (e.target !== svg) return;
                if (state.mode === 'pan') {
                    isPanning = true;
                    panStartPoint = { x: e.clientX, y: e.clientY };
                } else if (state.mode === 'addVertex') {
                    const coords = getSVGCoords(e);
                    addVertex(coords.x, coords.y);
                } else if (state.mode === 'select') {
                    isMarqueeSelecting = true;
                    marqueeStartPoint = getSVGCoords(e);
                    marqueeRect = document.createElementNS(NS, 'rect');
                    marqueeRect.classList.add('marquee-rect');
                    marqueeRect.setAttribute('x', marqueeStartPoint.x);
                    marqueeRect.setAttribute('y', marqueeStartPoint.y);
                    marqueeRect.setAttribute('width', 0);
                    marqueeRect.setAttribute('height', 0);
                    svg.appendChild(marqueeRect);
                }
            });

            window.addEventListener('mousemove', (e) => {
                const coords = getSVGCoords(e);
                lastMouseCoords = coords;
                if (isPanning) {
                    const dx = (e.clientX - panStartPoint.x) / state.zoom;
                    const dy = (e.clientY - panStartPoint.y) / state.zoom;
                    state.pan.x -= dx;
                    state.pan.y -= dy;
                    panStartPoint = { x: e.clientX, y: e.clientY };
                    render();
                    return;
                }
                if (isMarqueeSelecting && marqueeRect) { const x = Math.min(coords.x, marqueeStartPoint.x), y = Math.min(coords.y, marqueeStartPoint.y), width = Math.abs(coords.x - marqueeStartPoint.x), height = Math.abs(coords.y - marqueeStartPoint.y); marqueeRect.setAttribute('x', x); marqueeRect.setAttribute('y', y); marqueeRect.setAttribute('width', width); marqueeRect.setAttribute('height', height); return; }
                if (!state.draggedElement) return;
                
                if (state.draggedElement.type === 'vertex') {
                    const dx = (e.clientX - state.draggedElement.startX) / state.zoom;
                    const dy = (e.clientY - state.draggedElement.startY) / state.zoom;
                    
                    const selectedVertexIds = new Set(state.selectedElements.filter(el => el.type === 'vertex').map(v => v.id));
                    if (!selectedVertexIds.has(state.draggedElement.id)) {
                        const draggedVertex = state.vertices.find(v => v.id === state.draggedElement.id);
                        draggedVertex.x += dx;
                        draggedVertex.y += dy;
                    } else {
                        state.vertices.forEach(v => { if (selectedVertexIds.has(v.id)) { v.x += dx; v.y += dy; } });
                    }
                    state.draggedElement.startX = e.clientX;
                    state.draggedElement.startY = e.clientY;
                } else if (state.draggedElement.type === 'handle') {
                    const edge = state.edges.find(e => e.id === state.draggedElement.edgeId);
                    if (edge) { edge.controlPoint.x = coords.x; edge.controlPoint.y = coords.y; edge.controlPoint.isDefault = false; }
                }
                render();
            });

            window.addEventListener('mouseup', (e) => {
                isPanning = false;
                if (isMarqueeSelecting && marqueeRect) {
                    const x = parseFloat(marqueeRect.getAttribute('x')), y = parseFloat(marqueeRect.getAttribute('y')), width = parseFloat(marqueeRect.getAttribute('width')), height = parseFloat(marqueeRect.getAttribute('height'));
                    const selectedInBox = state.vertices.filter(v => v.x >= x && v.x <= x + width && v.y >= y && v.y <= y + height);
                    
                    if (e.shiftKey) {
                        selectedInBox.forEach(item => { if (!state.selectedElements.some(sel => sel.type === item.type && sel.id === item.id)) { state.selectedElements.push(item); } });
                    } else {
                        state.selectedElements = selectedInBox;
                    }
                    marqueeRect.remove();
                    marqueeRect = null;
                    isMarqueeSelecting = false;
                    updatePropertiesPanel();
                    updateToolbarButtons();
                    render();
                }
                if (state.draggedElement) {
                    if (state.draggedElement.type === 'vertex') {
                        saveState();
                    } else if (state.draggedElement.type === 'handle') {
                        saveState();
                    }
                    state.draggedElement = null;
                    render();
                }
            });

            window.addEventListener('keydown', (e) => { if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; const isCtrlOrMeta = e.ctrlKey || e.metaKey; if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedElements(); else if (e.key === 'Escape') { setMode('select'); selectElement(null); render(); } else if (e.key === 'e' && !isCtrlOrMeta) { e.preventDefault(); addEdgeBtn.click(); } else if (e.key === 'l' && !isCtrlOrMeta) { e.preventDefault(); const opts = Array.from(autoLabelTypeSelect.options); const curIdx = opts.findIndex(opt => opt.value === state.autoLabelType); autoLabelTypeSelect.value = opts[(curIdx + 1) % opts.length].value; autoLabelTypeSelect.dispatchEvent(new Event('change')); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'c') { e.preventDefault(); copySelection(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'x') { e.preventDefault(); copySelection(); deleteSelectedElements(); } else if (isCtrlOrMeta && e.key.toLowerCase() === 'v') { e.preventDefault(); pasteFromClipboard(); } });
            
            const inputs = [vertexLabelInput, vertexSizeSelect, vertexFillTypeSelect, vertexColorInput, vertexBorderSelect, edgeTypeSelect, edgeStyleSelect];
            inputs.forEach(input => { input.addEventListener('change', (e) => { if (state.selectedElements.length !== 1) return; const el = state.selectedElements[0]; switch (e.target.id) { case 'vertex-label': el.label = e.target.value; break; case 'vertex-size': el.radius = parseInt(e.target.value); break; case 'vertex-fill-type': el.fillType = e.target.value; vertexColorGroup.style.display = el.fillType === 'solid' ? 'block' : 'none'; break; case 'vertex-color': el.fillColor = e.target.value; break; case 'vertex-border': el.borderWidth = parseFloat(e.target.value); break; case 'edge-type': el.edgeType = e.target.value; break; case 'edge-style': el.lineStyle = e.target.value; break; } saveState(); render(); }); });

            saveState();
            setMode('select');
        });
    </script>

</body>
</html>
